{
  "version": 3,
  "sources": ["../src/index.ts", "../src/core/hmsSDKStore/HMSReactiveStore.ts", "../src/core/hmsSDKStore/HMSNotifications.ts", "../src/core/schema/room.ts", "../src/core/schema/schema.ts", "../src/core/schema/message.ts", "../src/core/schema/notification.ts", "../src/core/schema/playlist.ts", "../src/core/hmsSDKStore/sdkTypes.ts", "../src/core/hmsSDKStore/common/mapping.ts", "../src/core/selectors/selectors.ts", "../src/core/selectors/selectorUtils.ts", "../src/core/selectors/playlistselectors.ts", "../src/core/selectors/selectorsByID.ts", "../src/core/selectors/common.ts", "../src/common/ui-logger.ts", "../src/core/selectors/derivedSelectors.ts", "../src/core/selectors/selectorsByReference.ts", "../src/core/hmsSDKStore/HMSSDKActions.ts", "../src/core/hmsSDKStore/sdkUtils/sdkUtils.ts", "../src/core/hmsSDKStore/sdkUtils/storeMergeUtils.ts", "../src/core/hmsSDKStore/adapter.ts", "../src/core/hmsSDKStore/HMSPlaylist.ts", "../src/core/hmsSDKStore/HMSSessionStore.ts", "../src/controller/beam/BeamSpeakerLabelsLogger.ts", "../src/common/storeName.ts", "../src/controller/beam/BeamController.ts", "../src/core/webrtc-stats/webrtc-stats-store.ts", "../src/core/webrtc-stats/HMSStats.ts", "../src/core/webrtc-stats/selectors.ts"],
  "sourcesContent": ["export * from './core';\n", "import produce from 'immer';\nimport shallow from 'zustand/shallow';\nimport create, {\n  EqualityChecker,\n  PartialState,\n  SetState,\n  State,\n  StateSelector,\n  StateSliceListener,\n  StoreApi,\n} from 'zustand/vanilla';\nimport { HMSSdk, isBrowser } from '@100mslive/hms-video';\nimport { HMSNotifications } from './HMSNotifications';\nimport { HMSSDKActions } from './HMSSDKActions';\nimport { NamedSetState } from './internalTypes';\nimport { storeNameWithTabTitle } from '../../common/storeName';\nimport { BeamControllerStore } from '../../controller/beam/BeamController';\nimport { IHMSActions } from '../IHMSActions';\nimport { IHMSStatsStoreReadOnly, IHMSStore, IHMSStoreReadOnly, IStore } from '../IHMSStore';\nimport { createDefaultStoreState, HMSGenericTypes, HMSStore } from '../schema';\nimport { IHMSNotifications } from '../schema/notification';\nimport { HMSStats } from '../webrtc-stats';\n\ndeclare global {\n  interface Window {\n    __hms: HMSReactiveStore;\n    __beam: BeamControllerStore;\n    __triggerBeamEvent__: (args: any) => void;\n  }\n}\n\nexport class HMSReactiveStore<T extends HMSGenericTypes = { sessionStore: Record<string, any> }> {\n  private readonly sdk?: HMSSdk;\n  private readonly actions: IHMSActions<T>;\n  private readonly store: IHMSStore<T>;\n  private readonly notifications: HMSNotifications<T>;\n  private stats?: HMSStats;\n  /** @TODO store flag for both HMSStore and HMSInternalsStore */\n  private initialTriggerOnSubscribe: boolean;\n\n  constructor(hmsStore?: IHMSStore<T>, hmsActions?: IHMSActions<T>, hmsNotifications?: HMSNotifications<T>) {\n    if (hmsStore) {\n      this.store = hmsStore;\n    } else {\n      this.store = HMSReactiveStore.createNewHMSStore<HMSStore<T>>(\n        storeNameWithTabTitle('HMSStore'),\n        createDefaultStoreState,\n      );\n    }\n    if (hmsNotifications) {\n      this.notifications = hmsNotifications;\n    } else {\n      this.notifications = new HMSNotifications(this.store);\n    }\n    if (hmsActions) {\n      this.actions = hmsActions;\n    } else {\n      this.sdk = new HMSSdk();\n      this.actions = new HMSSDKActions(this.store, this.sdk, this.notifications);\n    }\n\n    // @ts-ignore\n    this.actions.setFrameworkInfo({ type: 'js', sdkVersion: require('../../../package.json').version });\n\n    this.initialTriggerOnSubscribe = false;\n\n    if (isBrowser) {\n      // @ts-ignore\n      window.__hms = this;\n      // @ts-ignore\n      window.__beam = new BeamControllerStore<T>(this.store, this.actions, this.notifications);\n    }\n  }\n\n  /**\n   * By default store.subscribe does not call the handler with the current state at time of subscription,\n   * this behaviour can be modified by calling this function. What it means is that instead of calling the\n   * handler only for changes which happen post subscription we'll also call it exactly once at the time\n   * of subscription with the current state. This behaviour is similar to that of BehaviourSubject in rxjs.\n   * This will be an irreversible change\n   *\n   * Note: you don't need this if you're using our react hooks, it takes care of this requirement.\n   */\n  triggerOnSubscribe(): void {\n    if (this.initialTriggerOnSubscribe) {\n      // already done\n      return;\n    }\n    HMSReactiveStore.makeStoreTriggerOnSubscribe(this.store);\n    this.initialTriggerOnSubscribe = true;\n  }\n\n  /**\n   * A reactive store which has a subscribe method you can use in combination with selectors\n   * to subscribe to a subset of the store. The store serves as a single source of truth for\n   * all data related to the corresponding HMS Room.\n   */\n  getStore(): IHMSStoreReadOnly {\n    return this.store;\n  }\n\n  /**\n   * Any action which may modify the store or may need to talk to the SDK will happen\n   * through the IHMSActions instance returned by this\n   *\n   * @deprecated use getActions\n   */\n  getHMSActions(): IHMSActions<T> {\n    return this.actions;\n  }\n\n  /**\n   * Any action which may modify the store or may need to talk to the SDK will happen\n   * through the IHMSActions instance returned by this\n   */\n  getActions(): IHMSActions<T> {\n    return this.actions;\n  }\n\n  /**\n   * This return notification handler function to which you can pass your callback to\n   * receive notifications like peer joined, peer left, etc. to show in your UI or use\n   * for analytics\n   */\n  getNotifications(): IHMSNotifications {\n    return { onNotification: this.notifications.onNotification };\n  }\n\n  /**\n   * @alpha\n   */\n  getStats = (): IHMSStatsStoreReadOnly => {\n    if (!this.stats) {\n      this.stats = new HMSStats(this.store as unknown as IHMSStore, this.sdk);\n    }\n    return this.stats;\n  };\n\n  /**\n   * @internal\n   */\n  static createNewHMSStore<T extends State>(storeName: string, defaultCreatorFn: () => T): IStore<T> {\n    const hmsStore = create<T>(() => defaultCreatorFn());\n    // make set state immutable, by passing functions through immer\n    const savedSetState = hmsStore.setState;\n    hmsStore.setState = (partial: any) => {\n      const nextState = typeof partial === 'function' ? produce(partial) : partial;\n      savedSetState(nextState);\n    };\n    // add option to pass selector to getState\n    const prevGetState = hmsStore.getState;\n    // eslint-disable-next-line complexity\n    hmsStore.getState = <StateSlice>(selector?: StateSelector<T, StateSlice>) => {\n      return selector ? selector(prevGetState()) : prevGetState();\n    };\n    HMSReactiveStore.compareWithShallowCheckInSubscribe(hmsStore);\n    const namedSetState = HMSReactiveStore.setUpDevtools(hmsStore, storeName);\n    return { ...hmsStore, namedSetState };\n  }\n\n  /**\n   * @internal\n   */\n  static makeStoreTriggerOnSubscribe<T extends State>(store: IStore<T>) {\n    const prevSubscribe = store.subscribe;\n    store.subscribe = <StateSlice>(\n      listener: StateSliceListener<StateSlice>,\n      selector?: StateSelector<T, StateSlice>,\n      equalityFn?: EqualityChecker<StateSlice>,\n    ): (() => void) => {\n      // initial call, the prev state will always be null for this\n      listener(store.getState(selector), undefined as unknown as StateSlice);\n      // then subscribe\n      return prevSubscribe(listener, selector!, equalityFn);\n    };\n  }\n\n  /**\n   * use shallow equality check by default for subscribe to optimize for array/object selectors.\n   * by default zustand does only reference matching so something like, getPeers for eg. would trigger\n   * the corresponding component even if peers didn't actually change, as selectPeers creates a new array every time.\n   * Although the array reference changes, the order of peers and peer objects don't themselves change in this case,\n   * and a shallow check avoids that triggering.\n   * @private\n   */\n  private static compareWithShallowCheckInSubscribe<T extends State>(hmsStore: StoreApi<T>) {\n    const prevSubscribe = hmsStore.subscribe;\n    hmsStore.subscribe = <StateSlice>(\n      listener: StateSliceListener<StateSlice>,\n      selector?: StateSelector<T, StateSlice>,\n      equalityFn?: EqualityChecker<StateSlice>,\n    ): (() => void) => {\n      if (!selector) {\n        selector = (store): StateSlice => store as unknown as StateSlice;\n      }\n      equalityFn = equalityFn || shallow;\n      return prevSubscribe(listener, selector, equalityFn);\n    };\n  }\n\n  /**\n   * @private\n   * @privateRemarks\n   * sets up redux devtools for the store, so redux extension can be used to visualize the store.\n   * zustand's default devtool middleware only enhances the set function, we're here creating another nameSetState in\n   * IHMStore which behaves like setState but takes an extra parameter for action name\n   * https://github.com/zalmoxisus/redux-devtools-extension/blob/master/docs/API/Methods.md\n   * modified version of zustand's devtools - https://github.com/pmndrs/zustand/blob/v3.5.7/src/middleware.ts#L46\n   */\n  private static setUpDevtools<T extends State>(api: StoreApi<T>, prefix: string): NamedSetState<T> {\n    let extension;\n    try {\n      extension = (window as any).__REDUX_DEVTOOLS_EXTENSION__ || (window as any).top.__REDUX_DEVTOOLS_EXTENSION__;\n    } catch {}\n    if (!extension) {\n      return (fn: any) => {\n        api.setState(fn);\n      };\n    }\n    const devtools = extension.connect(HMSReactiveStore.devtoolsOptions(prefix));\n    devtools.prefix = prefix ? `${prefix} > ` : '';\n    const savedSetState = api.setState;\n    api.setState = (fn: any) => {\n      savedSetState(fn);\n      devtools.send(`${devtools.prefix}setState`, api.getState());\n    };\n\n    devtools.subscribe(HMSReactiveStore.devtoolsSubscribe(devtools, api, savedSetState));\n\n    devtools.send('setUpStore', api.getState());\n\n    return (fn: any, action?: string) => {\n      savedSetState(fn);\n      const actionName = action ? action : `${devtools.prefix}action`;\n      devtools.send(actionName, api.getState());\n    };\n  }\n\n  /**\n   * https://github.com/zalmoxisus/redux-devtools-extension/blob/master/docs/API/Arguments.md\n   */\n  private static devtoolsOptions(prefix: string) {\n    return {\n      name: prefix,\n      actionsBlacklist: ['audioLevel', 'playlistProgress', 'connectionQuality'], // very high frequency update, pollutes the action history\n    };\n  }\n\n  /**\n   * redux devtools allows for time travel debugging where it sends an action to update the store, users can\n   * also export and import state in the devtools, listen to the corresponding functions from devtools and take\n   * required action.\n   * @param devtools - reference to devtools extension object\n   * @param api\n   * @param savedSetState - setState saved before its modified to update devtools\n   * @private\n   */\n  private static devtoolsSubscribe<T extends State>(devtools: any, api: StoreApi<T>, savedSetState: SetState<T>) {\n    // disabling complexity check instead of refactoring so as to keep the code close to zustand's and make\n    // any future update based on upstream changes easier.\n    // eslint-disable-next-line complexity\n    return (message: any) => {\n      if (message.type === 'DISPATCH' && message.state) {\n        const ignoreState = ['JUMP_TO_ACTION', 'JUMP_TO_STATE'].includes(message.payload.type);\n        if (!ignoreState) {\n          // manual dispatch from the extension\n          api.setState(JSON.parse(message.state));\n        } else {\n          // for time travel, no need to add new state changes in devtools\n          savedSetState(JSON.parse(message.state));\n        }\n      } else if (message.type === 'DISPATCH' && message.payload?.type === 'COMMIT') {\n        devtools.init(api.getState());\n      } else if (message.type === 'DISPATCH' && message.payload?.type === 'IMPORT_STATE') {\n        const actions = message.payload.nextLiftedState?.actionsById;\n        const computedStates = message.payload.nextLiftedState?.computedStates || [];\n\n        computedStates.forEach(({ state }: { state: PartialState<T> }, index: number) => {\n          const action = actions[index] || `${devtools.prefix}setState`;\n          if (index === 0) {\n            devtools.init(state);\n          } else {\n            savedSetState(state);\n            devtools.send(action, api.getState());\n          }\n        });\n      }\n    };\n  }\n}\n", "import { EventEmitter2 as EventEmitter } from 'eventemitter2';\nimport { PEER_NOTIFICATION_TYPES, TRACK_NOTIFICATION_TYPES } from './common/mapping';\nimport * as sdkTypes from './sdkTypes';\nimport { IHMSStore } from '../IHMSStore';\nimport {\n  HMSChangeMultiTrackStateRequest,\n  HMSChangeTrackStateRequest,\n  HMSDeviceChangeEvent,\n  HMSException,\n  HMSGenericTypes,\n  HMSLeaveRoomRequest,\n  HMSMessage,\n  HMSNotification,\n  HMSNotificationSeverity,\n  HMSNotificationTypes,\n  HMSPeer,\n  HMSPlaylistItem,\n  HMSTrack,\n  HMSTrackID,\n} from '../schema';\nimport {\n  HMSNotificationCallback,\n  HMSNotificationInCallback,\n  HMSNotificationTypeParam,\n  IHMSNotifications,\n} from '../schema/notification';\nimport { selectPeerByID, selectTrackByID } from '../selectors';\n\nconst HMS_NOTIFICATION_EVENT = 'hmsNotification';\n\nexport class HMSNotifications<T extends HMSGenericTypes = { sessionStore: Record<string, any> }>\n  implements IHMSNotifications\n{\n  private id = 0;\n  private eventEmitter: EventEmitter;\n  private store: IHMSStore<T>;\n\n  constructor(store: IHMSStore<T>) {\n    this.store = store;\n    this.eventEmitter = new EventEmitter({ maxListeners: Object.keys(HMSNotificationTypes).length });\n  }\n  onNotification = <T extends HMSNotificationTypeParam>(cb: HMSNotificationCallback<T>, type?: T) => {\n    const eventCallback = (notification: HMSNotificationInCallback<T>) => {\n      if (type) {\n        let matchesType: boolean;\n        if (Array.isArray(type)) {\n          matchesType = type.includes(notification.type as HMSNotificationTypes);\n        } else {\n          matchesType = type === notification.type;\n        }\n        if (!matchesType) {\n          return;\n        }\n      }\n      cb(notification);\n    };\n    this.eventEmitter.addListener(HMS_NOTIFICATION_EVENT, eventCallback);\n    return () => {\n      this.eventEmitter.removeListener(HMS_NOTIFICATION_EVENT, eventCallback);\n    };\n  };\n\n  sendPlaylistTrackEnded<T>(item: HMSPlaylistItem<T>): void {\n    const notification = this.createNotification(\n      HMSNotificationTypes.PLAYLIST_TRACK_ENDED,\n      item,\n      HMSNotificationSeverity.INFO,\n    );\n    this.emitEvent(notification);\n  }\n\n  sendDeviceChange(request: HMSDeviceChangeEvent) {\n    const notification = this.createNotification(\n      HMSNotificationTypes.DEVICE_CHANGE_UPDATE,\n      request,\n      request.error ? HMSNotificationSeverity.ERROR : HMSNotificationSeverity.INFO,\n      `Selected ${request.type} device - ${request.selection?.label}`,\n    );\n    this.emitEvent(notification);\n  }\n\n  sendLeaveRoom(request: HMSLeaveRoomRequest) {\n    const peerName = request.requestedBy?.name;\n    const notification = this.createNotification(\n      request.roomEnded || !peerName ? HMSNotificationTypes.ROOM_ENDED : HMSNotificationTypes.REMOVED_FROM_ROOM,\n      request,\n      HMSNotificationSeverity.INFO,\n      `${request.roomEnded ? `Room ended` : 'Removed from room'} ${peerName ? `by ${peerName}` : ''}`,\n    );\n    this.emitEvent(notification);\n  }\n\n  sendPeerList(peers: HMSPeer[]) {\n    const notification = this.createNotification(HMSNotificationTypes.PEER_LIST, peers, HMSNotificationSeverity.INFO);\n    this.emitEvent(notification);\n  }\n\n  sendPeerUpdate(type: sdkTypes.HMSPeerUpdate, peer: HMSPeer | null) {\n    const hmsPeer = this.store.getState(selectPeerByID(peer?.id)) || peer;\n    const notificationType = PEER_NOTIFICATION_TYPES[type];\n    if (notificationType) {\n      const notification = this.createNotification(notificationType, hmsPeer, HMSNotificationSeverity.INFO);\n      this.emitEvent(notification);\n    }\n  }\n\n  sendTrackUpdate(type: sdkTypes.HMSTrackUpdate, trackID: HMSTrackID) {\n    const hmsTrack = this.store.getState(selectTrackByID(trackID));\n    const notificationType = TRACK_NOTIFICATION_TYPES[type];\n    if (notificationType) {\n      const notification = this.createNotification(notificationType, hmsTrack, HMSNotificationSeverity.INFO);\n      this.emitEvent(notification);\n    }\n  }\n\n  sendMessageReceived(message: HMSMessage) {\n    const notification = this.createNotification(\n      HMSNotificationTypes.NEW_MESSAGE,\n      message,\n      HMSNotificationSeverity.INFO,\n    );\n    this.emitEvent(notification);\n  }\n\n  sendError(error: HMSException) {\n    const notification = this.createNotification(HMSNotificationTypes.ERROR, error, HMSNotificationSeverity.ERROR);\n    this.emitEvent(notification);\n  }\n\n  sendReconnecting(error: HMSException) {\n    const notification = this.createNotification(\n      HMSNotificationTypes.RECONNECTING,\n      error,\n      HMSNotificationSeverity.ERROR,\n    );\n    this.emitEvent(notification);\n  }\n\n  sendReconnected() {\n    const notification = this.createNotification(HMSNotificationTypes.RECONNECTED, null, HMSNotificationSeverity.INFO);\n    this.emitEvent(notification);\n  }\n\n  sendChangeTrackStateRequest(request: HMSChangeTrackStateRequest) {\n    const notification = this.createNotification(\n      HMSNotificationTypes.CHANGE_TRACK_STATE_REQUEST,\n      request,\n      HMSNotificationSeverity.INFO,\n    );\n    this.emitEvent(notification);\n  }\n\n  sendChangeMultiTrackStateRequest(request: HMSChangeMultiTrackStateRequest) {\n    const notification = this.createNotification(\n      HMSNotificationTypes.CHANGE_MULTI_TRACK_STATE_REQUEST,\n      request,\n      HMSNotificationSeverity.INFO,\n    );\n    this.emitEvent(notification);\n  }\n\n  private emitEvent(notification: HMSNotification) {\n    this.eventEmitter.emit(HMS_NOTIFICATION_EVENT, notification);\n  }\n\n  private createNotification<T>(\n    type: HMSNotificationTypes,\n    data?:\n      | HMSPeer\n      | HMSPeer[]\n      | HMSTrack\n      | HMSMessage\n      | HMSException\n      | HMSChangeTrackStateRequest\n      | HMSChangeMultiTrackStateRequest\n      | HMSLeaveRoomRequest\n      | HMSDeviceChangeEvent\n      | HMSPlaylistItem<T>\n      | null,\n    severity?: HMSNotificationSeverity,\n    message = '',\n  ): HMSNotification {\n    this.id++;\n    return {\n      id: this.id,\n      type,\n      message,\n      data,\n      severity,\n    } as HMSNotification;\n  }\n}\n", "import { HLSVariant, HMSHLS, HMSRecording, HMSRTMP } from '@100mslive/hms-video';\nimport { HMSPeerID } from './peer';\n\nexport type { HMSRecording, HMSRTMP, HMSHLS, HLSVariant };\nexport type HMSRoomID = string;\n\n/**\n * Check out internal-docs/RoomStateFlow.tldr for flow of room state\n * View it by\n * - Installing tldraw for VSCode(https://marketplace.visualstudio.com/items?itemName=tldraw-org.tldraw-vscode), or\n * - Open the file in https://www.tldraw.com/\n */\nexport enum HMSRoomState {\n  Disconnected = 'Disconnected',\n  Preview = 'Preview',\n  Connecting = 'Connecting',\n  Connected = 'Connected',\n  Reconnecting = 'Reconnecting',\n  Disconnecting = 'Disconnecting',\n  Failed = 'Failed',\n}\n\nexport interface HMSRoom {\n  id: HMSRoomID;\n  name: string;\n  isConnected?: boolean;\n  peers: HMSPeerID[];\n  localPeer: HMSPeerID;\n  roomState: HMSRoomState;\n  recording: HMSRecording;\n  rtmp: HMSRTMP;\n  hls: HMSHLS;\n  sessionId: string;\n  startedAt?: Date;\n  joinedAt?: Date;\n  /**\n   * if this number is available room.peers is not guaranteed to have all the peers.\n   */\n  peerCount?: number;\n}\n", "import { HMSException } from './error';\nimport { HMSMessage, HMSMessageID } from './message';\nimport { HMSPeer, HMSPeerID, HMSSpeaker, HMSTrack, HMSTrackID } from './peer';\nimport { HMSPlaylist } from './playlist';\nimport { HMSRoleChangeStoreRequest } from './requests';\nimport { HMSRole } from './role';\nimport { HMSRoom, HMSRoomState } from './room';\nimport { HMSMediaSettings } from './settings';\nimport { DeviceMap, HMSConnectionQuality, HMSPeerStats, HMSTrackStats } from '../hmsSDKStore/sdkTypes';\n\nexport interface HMSGenericTypes {\n  sessionStore: Record<string, any>;\n}\n\n/*\n * Defines the schema of the central store. UI Components are aware of the presence\n * of this central store. This is the global state - the single source of immutable truth.\n */\nexport interface HMSStore<T extends HMSGenericTypes = { sessionStore: Record<string, any> }> {\n  room: HMSRoom;\n  peers: Record<HMSPeerID, HMSPeer>;\n  speakers: Record<HMSTrackID, HMSSpeaker>;\n  connectionQualities: Record<HMSPeerID, HMSConnectionQuality>;\n  tracks: Record<HMSTrackID, HMSTrack>;\n  playlist: HMSPlaylist<any>;\n  messages: {\n    byID: Record<HMSMessageID, HMSMessage>;\n    allIDs: HMSMessageID[];\n  };\n  settings: HMSMediaSettings;\n  devices: DeviceMap;\n  roles: Record<string, HMSRole>;\n  templateAppData: Record<string, string>;\n  appData?: Record<string, any>;\n  roleChangeRequests: HMSRoleChangeStoreRequest[];\n  /** @deprecated use `sessionStore` instead */\n  sessionMetadata?: any;\n  preview?: {\n    localPeer?: HMSPeerID;\n    asRole?: string;\n    videoTrack?: HMSTrackID;\n    audioTrack?: HMSTrackID;\n  };\n  errors: HMSException[]; // for the convenience of debugging and seeing any error in devtools\n  sessionStore: T['sessionStore'];\n}\n\nexport interface HMSStatsStore {\n  remoteTrackStats: Record<HMSTrackID, HMSTrackStats | undefined>;\n  localTrackStats: Record<HMSTrackID, HMSTrackStats[] | undefined>;\n  peerStats: Record<HMSPeerID, HMSPeerStats | undefined>;\n  localPeer: {\n    id: HMSPeerID;\n    videoTrack?: HMSTrackID;\n    audioTrack?: HMSTrackID;\n  };\n}\n\n/**\n * @internal\n */\nexport const createDefaultStoreState = <T extends HMSGenericTypes>(): HMSStore<T> => {\n  return {\n    room: {\n      id: '',\n      isConnected: false,\n      name: '',\n      peers: [],\n      localPeer: '',\n      roomState: HMSRoomState.Disconnected,\n      recording: {\n        browser: {\n          running: false,\n        },\n        server: {\n          running: false,\n        },\n        hls: { running: false },\n      },\n      rtmp: {\n        running: false,\n      },\n      hls: {\n        running: false,\n        variants: [],\n      },\n      sessionId: '',\n    },\n    peers: {},\n    tracks: {},\n    playlist: {\n      audio: {\n        list: {},\n        selection: { id: '', hasPrevious: false, hasNext: false },\n        progress: 0,\n        volume: 0,\n        currentTime: 0,\n        playbackRate: 1.0,\n      },\n      video: {\n        list: {},\n        selection: { id: '', hasPrevious: false, hasNext: false },\n        progress: 0,\n        volume: 0,\n        currentTime: 0,\n        playbackRate: 1.0,\n      },\n    },\n    messages: { byID: {}, allIDs: [] },\n    speakers: {},\n    connectionQualities: {},\n    settings: {\n      audioInputDeviceId: '',\n      audioOutputDeviceId: '',\n      videoInputDeviceId: '',\n    },\n    devices: {\n      audioInput: [],\n      audioOutput: [],\n      videoInput: [],\n    },\n    roles: {},\n    roleChangeRequests: [],\n    errors: [],\n    sessionStore: {},\n    templateAppData: {},\n  };\n};\n\nexport const createDefaultStatsStore = (): HMSStatsStore => {\n  return {\n    peerStats: {},\n    remoteTrackStats: {},\n    localTrackStats: {},\n    localPeer: { id: '' },\n  };\n};\n", "import { HMSPeerID } from './peer';\nimport { HMSRoleName } from './role';\n\nexport type HMSMessageID = string;\n\n/**\n * @internal\n */\nexport enum HMSMessageType {\n  CHAT = 'chat',\n}\n\nexport interface HMSMessage {\n  id: HMSMessageID;\n  sender?: HMSPeerID;\n  senderName?: string;\n  senderUserId?: string;\n  senderRole?: string;\n  recipientPeer?: HMSPeerID;\n  recipientRoles?: HMSRoleName[];\n  time: Date;\n  read: boolean;\n  type: string;\n  message: any;\n  /**\n   * true if message will not be put it in store because it has been ignored\n   */\n  ignored: boolean;\n}\n\n/**\n * @internal\n */\nexport interface HMSMessageInput {\n  recipientPeer?: HMSPeerID;\n  recipientRoles?: HMSRoleName[];\n  type?: string;\n  message: any;\n}\n", "import { HMSDeviceChangeEvent } from './device-change';\nimport { HMSException } from './error';\nimport { HMSMessage } from './message';\nimport { HMSPeer, HMSTrack } from './peer';\nimport { HMSPlaylistItem } from './playlist';\nimport { HMSChangeMultiTrackStateRequest, HMSChangeTrackStateRequest, HMSLeaveRoomRequest } from './requests';\n\ninterface BaseNotification {\n  id: number;\n  type: string;\n  message: string;\n  severity?: HMSNotificationSeverity;\n}\nexport interface HMSPeerNotification extends BaseNotification {\n  type:\n    | HMSNotificationTypes.PEER_JOINED\n    | HMSNotificationTypes.PEER_LEFT\n    | HMSNotificationTypes.NAME_UPDATED\n    | HMSNotificationTypes.METADATA_UPDATED\n    | HMSNotificationTypes.ROLE_UPDATED;\n  data: HMSPeer;\n}\n\nexport interface HMSPeerListNotification extends BaseNotification {\n  type: HMSNotificationTypes.PEER_LIST;\n  data: HMSPeer[];\n}\nexport interface HMSTrackNotification extends BaseNotification {\n  type:\n    | HMSNotificationTypes.TRACK_ADDED\n    | HMSNotificationTypes.TRACK_DEGRADED\n    | HMSNotificationTypes.TRACK_UNMUTED\n    | HMSNotificationTypes.TRACK_DESCRIPTION_CHANGED\n    | HMSNotificationTypes.TRACK_MUTED\n    | HMSNotificationTypes.TRACK_REMOVED\n    | HMSNotificationTypes.TRACK_RESTORED;\n  data: HMSTrack;\n}\nexport interface HMSMessageNotification extends BaseNotification {\n  type: HMSNotificationTypes.NEW_MESSAGE;\n  data: HMSMessage;\n}\nexport interface HMSExceptionNotification extends BaseNotification {\n  type: HMSNotificationTypes.ERROR;\n  data: HMSException;\n}\nexport interface HMSChangeTrackStateRequestNotification extends BaseNotification {\n  type: HMSNotificationTypes.CHANGE_TRACK_STATE_REQUEST;\n  data: HMSChangeTrackStateRequest;\n}\nexport interface HMSChangeMultiTrackStateRequestNotification extends BaseNotification {\n  type: HMSNotificationTypes.CHANGE_MULTI_TRACK_STATE_REQUEST;\n  data: HMSChangeMultiTrackStateRequest;\n}\n\nexport interface HMSLeaveRoomRequestNotification extends BaseNotification {\n  type: HMSNotificationTypes.ROOM_ENDED | HMSNotificationTypes.REMOVED_FROM_ROOM;\n  data: HMSLeaveRoomRequest;\n}\nexport interface HMSDeviceChangeEventNotification extends BaseNotification {\n  type: HMSNotificationTypes.DEVICE_CHANGE_UPDATE;\n  data?: HMSDeviceChangeEvent;\n}\nexport interface HMSPlaylistItemNotification<T> extends BaseNotification {\n  type: HMSNotificationTypes.PLAYLIST_TRACK_ENDED;\n  data: HMSPlaylistItem<T>;\n}\n\nexport interface HMSReconnectionNotification extends BaseNotification {\n  type: HMSNotificationTypes.RECONNECTED | HMSNotificationTypes.RECONNECTING;\n  data: null;\n}\n\nexport type HMSNotification =\n  | HMSPeerNotification\n  | HMSPeerListNotification\n  | HMSTrackNotification\n  | HMSMessageNotification\n  | HMSExceptionNotification\n  | HMSChangeTrackStateRequestNotification\n  | HMSChangeMultiTrackStateRequestNotification\n  | HMSLeaveRoomRequestNotification\n  | HMSDeviceChangeEventNotification\n  | HMSReconnectionNotification\n  | HMSPlaylistItemNotification<any>;\n\nexport enum HMSNotificationSeverity {\n  INFO = 'info',\n  ERROR = 'error',\n}\n\nexport enum HMSNotificationTypes {\n  PEER_JOINED = 'PEER_JOINED',\n  PEER_LEFT = 'PEER_LEFT',\n  PEER_LIST = 'PEER_LIST',\n  NEW_MESSAGE = 'NEW_MESSAGE',\n  ERROR = 'ERROR',\n  RECONNECTING = 'RECONNECTING',\n  RECONNECTED = 'RECONNECTED',\n  TRACK_ADDED = 'TRACK_ADDED',\n  TRACK_REMOVED = 'TRACK_REMOVED',\n  TRACK_MUTED = 'TRACK_MUTED',\n  TRACK_UNMUTED = 'TRACK_UNMUTED',\n  TRACK_DEGRADED = 'TRACK_DEGRADED',\n  TRACK_RESTORED = 'TRACK_RESTORED',\n  TRACK_DESCRIPTION_CHANGED = 'TRACK_DESCRIPTION_CHANGED',\n  ROLE_UPDATED = 'ROLE_UPDATED',\n  CHANGE_TRACK_STATE_REQUEST = 'CHANGE_TRACK_STATE_REQUEST',\n  CHANGE_MULTI_TRACK_STATE_REQUEST = 'CHANGE_MULTI_TRACK_STATE_REQUEST',\n  ROOM_ENDED = 'ROOM_ENDED',\n  REMOVED_FROM_ROOM = 'REMOVED_FROM_ROOM',\n  DEVICE_CHANGE_UPDATE = 'DEVICE_CHANGE_UPDATE',\n  PLAYLIST_TRACK_ENDED = 'PLAYLIST_TRACK_ENDED',\n  NAME_UPDATED = 'NAME_UPDATED',\n  METADATA_UPDATED = 'METADATA_UPDATED',\n}\n\nexport type HMSNotificationMapping<T extends HMSNotificationTypes, C = any> = {\n  [HMSNotificationTypes.PEER_JOINED]: HMSPeerNotification;\n  [HMSNotificationTypes.PEER_LEFT]: HMSPeerNotification;\n  [HMSNotificationTypes.PEER_LIST]: HMSPeerListNotification;\n  [HMSNotificationTypes.NAME_UPDATED]: HMSPeerNotification;\n  [HMSNotificationTypes.METADATA_UPDATED]: HMSPeerNotification;\n  [HMSNotificationTypes.ROLE_UPDATED]: HMSPeerNotification;\n  [HMSNotificationTypes.TRACK_ADDED]: HMSTrackNotification;\n  [HMSNotificationTypes.TRACK_REMOVED]: HMSTrackNotification;\n  [HMSNotificationTypes.TRACK_MUTED]: HMSTrackNotification;\n  [HMSNotificationTypes.TRACK_UNMUTED]: HMSTrackNotification;\n  [HMSNotificationTypes.TRACK_DEGRADED]: HMSTrackNotification;\n  [HMSNotificationTypes.TRACK_RESTORED]: HMSTrackNotification;\n  [HMSNotificationTypes.TRACK_DESCRIPTION_CHANGED]: HMSTrackNotification;\n  [HMSNotificationTypes.TRACK_UNMUTED]: HMSTrackNotification;\n  [HMSNotificationTypes.NEW_MESSAGE]: HMSMessageNotification;\n  [HMSNotificationTypes.ROOM_ENDED]: HMSLeaveRoomRequestNotification;\n  [HMSNotificationTypes.REMOVED_FROM_ROOM]: HMSLeaveRoomRequestNotification;\n  [HMSNotificationTypes.DEVICE_CHANGE_UPDATE]: HMSDeviceChangeEventNotification;\n  [HMSNotificationTypes.PLAYLIST_TRACK_ENDED]: HMSPlaylistItemNotification<C>;\n  [HMSNotificationTypes.ERROR]: HMSExceptionNotification;\n  [HMSNotificationTypes.CHANGE_TRACK_STATE_REQUEST]: HMSChangeTrackStateRequestNotification;\n  [HMSNotificationTypes.CHANGE_MULTI_TRACK_STATE_REQUEST]: HMSChangeMultiTrackStateRequestNotification;\n  [HMSNotificationTypes.RECONNECTED]: HMSReconnectionNotification;\n  [HMSNotificationTypes.RECONNECTING]: HMSReconnectionNotification;\n}[T];\n\ntype MappedNotifications<Type extends HMSNotificationTypes[]> = {\n  [index in keyof Type]: HMSNotificationMapping<Type[index]>;\n};\n\nexport type HMSNotificationTypeParam = HMSNotificationTypes | HMSNotificationTypes[] | undefined;\n\nexport type HMSNotificationInCallback<T extends HMSNotificationTypeParam> = T extends HMSNotificationTypes[]\n  ? MappedNotifications<T>[number]\n  : T extends HMSNotificationTypes\n  ? HMSNotificationMapping<T>\n  : HMSNotification;\n\nexport type HMSNotificationCallback<T extends HMSNotificationTypeParam> = (\n  notification: HMSNotificationInCallback<T>,\n) => void;\n\n/**\n * @category Core\n */\nexport interface IHMSNotifications {\n  /**\n   * you can subscribe to notifications for new message, peer add etc. using this function.\n   * note that this is not meant to maintain any state on your side, as the reactive store already\n   * does that. The intent of this function is mainly to display toast notifications or send analytics.\n   * We'll provide a display message which can be displayed as it is for common cases.\n   */\n  onNotification<T extends HMSNotificationTypeParam>(cb: HMSNotificationCallback<T>, types?: T): () => void;\n}\n", "import { HMSStore } from '../schema';\n\nexport enum HMSPlaylistType {\n  audio = 'audio',\n  video = 'video',\n}\nexport interface HMSPlaylistItem<T> {\n  name: string;\n  id: string;\n  metadata?: T;\n  url: string;\n  type: HMSPlaylistType;\n  duration?: number;\n  playing: boolean;\n  selected: boolean;\n}\n\nexport interface HMSPlaylistSelection {\n  id: string;\n  hasPrevious: boolean;\n  hasNext: boolean;\n}\n\nexport interface HMSPlaylist<T> {\n  audio: {\n    list: Record<string, HMSPlaylistItem<T>>;\n    selection: HMSPlaylistSelection;\n    progress: number;\n    volume: number;\n    currentTime: number;\n    playbackRate: number;\n  };\n  video: {\n    list: Record<string, HMSPlaylistItem<T>>;\n    selection: HMSPlaylistSelection;\n    progress: number;\n    volume: number;\n    currentTime: number;\n    playbackRate: number;\n  };\n}\n\nexport interface IHMSPlaylistActions {\n  /**\n   * Pass the id of the item to be played\n   * @param {string} id - id of playlist item\n   */\n  play(id: string): Promise<void>;\n  /**\n   * Pauses current playing item\n   */\n  pause(): Promise<void>;\n  /**\n   * PlayNext\n   */\n  playNext(): Promise<void>;\n  /**\n   * PlayPrevious\n   */\n  playPrevious(): Promise<void>;\n  /**\n   * seek passing seekValue - this is relative to current position\n   * @param {number} seekValue - number in seconds to move forwards(pass negative values to move backwards)\n   */\n  seek(seekValue: number): void;\n  /**\n   * seek passing seekValue  - seekValue will be absolute\n   * @param {number} seekValue - value in seconds of absolute position in the playlist item duration\n   */\n  seekTo(seekValue: number): void;\n  /**\n   * set volume passing volume\n   * @param {number} volume - number between 0-100\n   */\n  setVolume(volume: number): void;\n  /**\n   * pass list to set playlist\n   * @param {HMSPlaylistItem[]} list of playlist items\n   */\n  setList<T>(list: HMSPlaylistItem<T>[]): void;\n  /**\n   * Stop the current playback and remove the tracks\n   */\n  stop(): Promise<void>;\n  /**\n   * set whether to autoplay next item in playlist after the current one ends\n   * @param {boolean} autoplay\n   */\n  setIsAutoplayOn(autoplay: boolean): void;\n  /**\n   * Control the playback speed - 1.0 being normal, less than 1.0 will play it slowly\n   * and more than 1.0 will play it faster.\n   * @param playbackRate - value from 0.25 and 2.0\n   */\n  setPlaybackRate(playbackRate: number): void;\n  removeItem(id: string): Promise<boolean>;\n  clearList(): Promise<void>;\n}\n\n/**\n * Helpful selectors for audio and video playlist\n */\nexport interface HMSPlaylistSelector {\n  /**\n   * returns the playlist items list as set initially\n   */\n  list: <T>(store: HMSStore) => HMSPlaylistItem<T>[];\n  /**\n   * This returns playlist selection with `{ id, hasNext, hasPrev }`\n   * @returns {HMSPlaylistSelection}\n   */\n  selection: (store: HMSStore) => HMSPlaylistSelection;\n  /**\n   * This returns playlist item for corresponding Id in selection\n   * @returns {HMSPlaylistItem}\n   */\n  selectedItem: <T>(store: HMSStore) => HMSPlaylistItem<T>;\n  /**\n   * returns the current progress percentage, a number between 0-100\n   */\n  progress: (store: HMSStore) => number;\n  /**\n   * returns the current volume the playlist is playing at, a number between 0-100\n   */\n  volume: (store: HMSStore) => number;\n  /**\n   * returns the current time of the playlist in seconds\n   */\n  currentTime: (store: HMSStore) => number;\n  /**\n   * returns the playback rate, a number between 0.25-2.0.\n   */\n  playbackRate: (store: HMSStore) => number;\n}\n", "import {\n  DeviceMap,\n  DeviceType,\n  HLSConfig,\n  HLSMeetingURLVariant,\n  HLSTimedMetadata,\n  HMSAudioPlugin,\n  HMSAudioPluginType,\n  HMSAudioTrackSettings,\n  HMSConfig,\n  HMSConfigInitialSettings,\n  HMSConnectionQuality,\n  HMSDeviceChangeEvent,\n  HMSException,\n  HMSFrameworkInfo,\n  HMSHLS,\n  HMSLocalPeer,\n  HMSLocalTrackStats,\n  HMSLogLevel,\n  HMSMessage,\n  HMSPeer,\n  HMSPeerStats,\n  HMSPeerUpdate,\n  HMSPlaylistItem,\n  HMSPlaylistManager,\n  HMSPlaylistProgressEvent,\n  HMSPreferredSimulcastLayer,\n  HMSPreviewConfig,\n  HMSRecording,\n  HMSRemotePeer,\n  HMSRemoteTrackStats,\n  HMSRole,\n  HMSRoom,\n  HMSRoomUpdate,\n  HMSRTMP,\n  HMSScreenShareConfig,\n  HMSSimulcastLayer,\n  HMSSimulcastLayerDefinition,\n  HMSSpeaker,\n  HMSTrackStats,\n  HMSTrackUpdate,\n  HMSVideoPlugin,\n  HMSVideoPluginCanvasContextType,\n  HMSVideoPluginType,\n  HMSVideoTrackSettings,\n  HMSWebrtcInternals,\n  HMSWebrtcStats,\n  parsedUserAgent,\n  RID,\n  RTMPRecordingConfig,\n  ScreenCaptureHandle,\n  simulcastMapping,\n  TokenRequest,\n  TokenRequestOptions,\n} from '@100mslive/hms-video';\n\nexport {\n  HMSException,\n  HMSSimulcastLayer,\n  HMSRoomUpdate,\n  HMSPeerUpdate,\n  HMSTrackUpdate,\n  HMSLogLevel,\n  HMSAudioPluginType,\n  HMSVideoPluginType,\n  HMSVideoPluginCanvasContextType,\n  parsedUserAgent,\n  simulcastMapping,\n  DeviceType,\n};\n\nexport type {\n  DeviceMap,\n  HMSPeer,\n  HMSRoom,\n  HMSMessage,\n  HMSSpeaker,\n  HMSConfig,\n  HMSConfigInitialSettings,\n  HMSPreviewConfig,\n  HMSAudioTrackSettings,\n  HMSVideoTrackSettings,\n  HMSRole,\n  HMSLocalPeer,\n  HMSRemotePeer,\n  HMSSimulcastLayerDefinition,\n  HMSDeviceChangeEvent,\n  HMSPlaylistItem,\n  HMSPlaylistManager,\n  HMSPlaylistProgressEvent,\n  RTMPRecordingConfig,\n  HMSRecording,\n  HMSRTMP,\n  HMSWebrtcInternals,\n  HMSWebrtcStats,\n  HMSVideoPlugin,\n  HMSAudioPlugin,\n  HLSConfig,\n  HLSTimedMetadata,\n  HLSMeetingURLVariant,\n  HMSHLS,\n  HMSPeerStats,\n  HMSTrackStats,\n  HMSLocalTrackStats,\n  HMSRemoteTrackStats,\n  HMSConnectionQuality,\n  HMSScreenShareConfig,\n  HMSFrameworkInfo,\n  RID,\n  ScreenCaptureHandle,\n  HMSPreferredSimulcastLayer,\n  TokenRequest,\n  TokenRequestOptions,\n};\n", "import { HMSNotificationTypes } from '../../schema';\nimport * as sdkTypes from '../sdkTypes';\n\ntype PeerNotificationMap = { [key in sdkTypes.HMSPeerUpdate]?: HMSNotificationTypes };\n\nexport const PEER_NOTIFICATION_TYPES: PeerNotificationMap = {\n  [sdkTypes.HMSPeerUpdate.PEER_JOINED]: HMSNotificationTypes.PEER_JOINED,\n  [sdkTypes.HMSPeerUpdate.PEER_LEFT]: HMSNotificationTypes.PEER_LEFT,\n  [sdkTypes.HMSPeerUpdate.ROLE_UPDATED]: HMSNotificationTypes.ROLE_UPDATED,\n  [sdkTypes.HMSPeerUpdate.NAME_UPDATED]: HMSNotificationTypes.NAME_UPDATED,\n  [sdkTypes.HMSPeerUpdate.METADATA_UPDATED]: HMSNotificationTypes.METADATA_UPDATED,\n};\n\ntype TrackNotificationMap = { [key in sdkTypes.HMSTrackUpdate]: HMSNotificationTypes };\nexport const TRACK_NOTIFICATION_TYPES: TrackNotificationMap = {\n  [sdkTypes.HMSTrackUpdate.TRACK_ADDED]: HMSNotificationTypes.TRACK_ADDED,\n  [sdkTypes.HMSTrackUpdate.TRACK_REMOVED]: HMSNotificationTypes.TRACK_REMOVED,\n  [sdkTypes.HMSTrackUpdate.TRACK_MUTED]: HMSNotificationTypes.TRACK_MUTED,\n  [sdkTypes.HMSTrackUpdate.TRACK_UNMUTED]: HMSNotificationTypes.TRACK_UNMUTED,\n  [sdkTypes.HMSTrackUpdate.TRACK_DEGRADED]: HMSNotificationTypes.TRACK_DEGRADED,\n  [sdkTypes.HMSTrackUpdate.TRACK_RESTORED]: HMSNotificationTypes.TRACK_RESTORED,\n  [sdkTypes.HMSTrackUpdate.TRACK_DESCRIPTION_CHANGED]: HMSNotificationTypes.TRACK_DESCRIPTION_CHANGED,\n};\n", "import { createSelector } from 'reselect';\nimport {\n  getScreenSharesByPeer,\n  isAudioPlaylist,\n  isDegraded,\n  isTrackDisplayEnabled,\n  isTrackEnabled,\n  isVideo,\n  isVideoPlaylist,\n} from './selectorUtils';\n// noinspection ES6PreferShortImport\nimport { HMSRole } from '../hmsSDKStore/sdkTypes';\nimport {\n  HMSException,\n  HMSMessage,\n  HMSPeer,\n  HMSPeerID,\n  HMSRoom,\n  HMSRoomState,\n  HMSStore,\n  HMSVideoTrack,\n} from '../schema';\n\n/**\n * Select the current {@link HMSRoom} object to which you are connected.\n * @param store\n */\nexport const selectRoom = (store: HMSStore): HMSRoom => store.room;\n/**\n * Select the current {@link HMSException[]} object to monitor the error logs\n * @param store\n */\nexport const selectErrors = (store: HMSStore): HMSException[] => store.errors;\n\n/**\n * It will help to get the all the error\n */\nexport const selectRecentError = createSelector(selectErrors, errors => (errors.length === 0 ? null : errors.at(-1)));\n/**\n * Select the ID of the current room to which you are connected.\n */\nexport const selectRoomID = createSelector(selectRoom, room => room.id);\n\n/**\n * @internal\n */\nexport const selectPeersMap = (store: HMSStore): Record<HMSPeerID, HMSPeer> => store.peers;\n\n/**\n * @internal\n */\nexport const selectMessagesMap = (store: HMSStore) => store.messages.byID;\n\n/**\n * Select IDs of messages you've sent or received sorted chronologically.\n */\nexport const selectMessageIDsInOrder = (store: HMSStore) => store.messages.allIDs;\n\n/**\n * @internal\n */\nexport const selectTracksMap = (store: HMSStore) => store.tracks;\n\n/**\n * Select your media settings\n * i.e., choosen audio input device, audio output device and video input device.\n * @param store\n */\nexport const selectLocalMediaSettings = (store: HMSStore) => store.settings;\n\n/**\n * select appData.\n * @internal\n */\nexport const selectFullAppData = (store: HMSStore) => store.appData;\n\n/**\n * Select the available audio input, audio output and video input devices on your machine.\n * @param store\n * @returns An object of array of available audio input, audio output and video input devices.\n * ```\n * type DeviceMap = {\n *   audioInput: InputDeviceInfo[];\n *   audioOutput: MediaDeviceInfo[];\n *   videoInput: InputDeviceInfo[];\n * }\n * ```\n */\nexport const selectDevices = (store: HMSStore) => {\n  return store.devices;\n};\n\nexport const selectSpeakers = (store: HMSStore) => {\n  return store.speakers;\n};\n\nexport const selectConnectionQualities = (store: HMSStore) => {\n  return store.connectionQualities;\n};\n\n/**\n * Select a boolean flag denoting whether you've joined a room.\n * NOTE: Returns true only after join, returns false during preview.\n */\nexport const selectIsConnectedToRoom = createSelector([selectRoom], room => room && room.isConnected);\n\n/**\n * selectPeerCount gives the number of peers Inside the room. This doesn't count the local peer if\n * they're still in preview and haven't yet joined the room. Note that this will not necessarily equal the\n * number of peers received through selectPeers, it's possible to know total number of people in the room\n * without having details of everyone depending on dashboard settings.\n */\nexport const selectPeerCount = createSelector([selectIsConnectedToRoom, selectRoom], (isConnected, room) => {\n  if (isConnected) {\n    // if we have peer count from server return that else return number of peers in the store.\n    // In case the strongly consistent peer list is disabled and only eventual consistent count and peer\n    // details is sent, room.peerCount may be 0 for a few second even though local peer is connected, send 1 in that case.\n    // TODO: Fix this at populating room.peerCount level than in selector.\n    return room.peerCount !== undefined ? room.peerCount || 1 : room.peers.length;\n  } else {\n    // if we have peer count from server return that, else return number of peers except the local one because local is\n    // not joined yet.\n    // Math.max to ensure we're not returning -1, if the selector is called before local peer is put in the store\n    return Math.max(room.peerCount !== undefined ? room.peerCount : room.peers.length - 1, 0);\n  }\n});\n\n/**\n * Select an array of peers(remote peers and your local peer) present in the room.\n */\nexport const selectPeers = createSelector([selectRoom, selectPeersMap], (room, storePeers) => {\n  return room.peers.map(peerID => storePeers[peerID]);\n});\n\n/**\n * Select an array of tracks(remote peer tracks and your local tracks) present in the room.\n */\nconst selectTracks = createSelector(selectTracksMap, storeTracks => {\n  return Object.values(storeTracks);\n});\n\n/**\n * Select the local peer object object assigned to you.\n */\nexport const selectLocalPeer = createSelector(selectRoom, selectPeersMap, (room, peers): HMSPeer | undefined => {\n  return peers[room.localPeer];\n});\n\n/**\n * Select the peer ID of your local peer.\n */\nexport const selectLocalPeerID = createSelector(selectRoom, room => {\n  return room.localPeer;\n});\n\n/**\n * Select the peer name of your local peer.\n */\nexport const selectLocalPeerName = createSelector(selectLocalPeer, peer => peer?.name);\n\n/**\n * Select the role name of your local peer.\n */\nexport const selectLocalPeerRoleName = createSelector(selectLocalPeer, peer => peer?.roleName);\n\n/**\n * Select the track ID of your local peer's primary audio track\n */\nexport const selectLocalAudioTrackID = createSelector(selectLocalPeer, peer => peer?.audioTrack);\n\n/**\n * Select the track ID of your local peer's primary video track\n */\nexport const selectLocalVideoTrackID = createSelector(selectLocalPeer, peer => peer?.videoTrack);\n\n/**\n * Select an array of track IDs of your local peer's auxiliary tracks\n */\nconst selectLocalAuxiliaryTrackIDs = createSelector(selectLocalPeer, peer => peer?.auxiliaryTracks);\n\n/**\n * Select an array of track IDs of all your local peer's tracks\n */\nexport const selectLocalTrackIDs = createSelector(\n  [selectLocalAudioTrackID, selectLocalVideoTrackID, selectLocalAuxiliaryTrackIDs],\n  (audioTrackID, videoTrackID, auxiliaryTrackIDs) => {\n    const trackIDs: string[] = auxiliaryTrackIDs ? [...auxiliaryTrackIDs] : [];\n    audioTrackID && trackIDs.unshift(audioTrackID);\n    videoTrackID && trackIDs.unshift(videoTrackID);\n    return trackIDs;\n  },\n);\n\n/**\n * Select remote peers(other users you're connected with via the internet) present in the room.\n */\nexport const selectRemotePeers = createSelector(selectPeers, peers => {\n  return peers.filter(p => !p.isLocal);\n});\n\n/**\n * Select the peer who's speaking the loudest at the moment\n */\nexport const selectDominantSpeaker = createSelector(selectPeersMap, selectSpeakers, (peersMap, speakers) => {\n  // sort in descending order by audio level\n  const speakersInOrder = Object.entries(speakers).sort((s1, s2) => {\n    const s1Level = s1[1]?.audioLevel || 0;\n    const s2Level = s2[1]?.audioLevel || 0;\n    return s2Level > s1Level ? 1 : -1;\n  });\n  if (speakersInOrder.length > 0 && speakersInOrder[0][1].audioLevel && speakersInOrder[0][1].audioLevel > 0) {\n    const peerID = speakersInOrder[0][1].peerID;\n    if (peerID in peersMap) {\n      return peersMap[peerID];\n    }\n  }\n  return null;\n});\n\n/**\n * Select a boolean denoting whether your local audio is unmuted\n * and the audio from your microphone is shared to remote peers\n */\nexport const selectIsLocalAudioEnabled = (store: HMSStore) => {\n  const localPeer = selectLocalPeer(store);\n  return isTrackEnabled(store, localPeer?.audioTrack);\n};\n\n/**\n * Select a boolean denoting whether your local video is unmuted\n * and the video from your camera is shared to remote peers\n */\nexport const selectIsLocalVideoEnabled = (store: HMSStore) => {\n  const localPeer = selectLocalPeer(store);\n  return isTrackEnabled(store, localPeer?.videoTrack);\n};\n\n/**\n * Select a boolean denoting whether you've chosen to unmute and share your local video.\n *\n * NOTE: Once you call `hmsActions.setLocalVideoEnabled(true)`to unmute your local video,\n * it takes some time to fetch your video from your video source.\n * This displayEnabled property gives immediate feedback for a more interactive UI,\n * without waiting for the video source\n */\nexport const selectIsLocalVideoDisplayEnabled = (store: HMSStore) => {\n  const localPeer = selectLocalPeer(store);\n  return isTrackDisplayEnabled(store, localPeer?.videoTrack);\n};\n\n/**\n * Select a boolean denoting whether your screen is shared to remote peers in the room.\n */\nexport const selectIsLocalScreenShared = createSelector(selectLocalPeer, selectTracksMap, (localPeer, tracksMap) => {\n  const { video, audio } = getScreenSharesByPeer(tracksMap, localPeer);\n  return !!(video || audio);\n});\n\n/**\n * Select the first peer who is currently sharing their screen.\n */\nexport const selectPeerScreenSharing = createSelector(selectPeersMap, selectTracksMap, (peersMap, tracksMap) => {\n  let screensharePeer = undefined;\n  for (const peerID in peersMap) {\n    const peer = peersMap[peerID];\n    const { video, audio } = getScreenSharesByPeer(tracksMap, peer);\n    if (video) {\n      return peer;\n    } else if (audio && !screensharePeer) {\n      screensharePeer = peer;\n    }\n  }\n  return screensharePeer;\n});\n\n/**\n * Select a boolean denoting whether someone is sharing screen in the room.\n */\nexport const selectIsSomeoneScreenSharing = createSelector(selectPeerScreenSharing, peer => {\n  return !!peer;\n});\n\n/**\n * Select the first peer who is currently sharing their audio only screen\n */\nexport const selectPeerSharingAudio = createSelector(selectPeersMap, selectTracksMap, (peersMap, tracksMap) => {\n  for (const peerID in peersMap) {\n    const peer = peersMap[peerID];\n    const { audio, video } = getScreenSharesByPeer(tracksMap, peer);\n    if (!video && !!audio) {\n      return peer;\n    }\n  }\n  return undefined;\n});\n\n/**\n * Select an array of peers who are currently sharing their screen.\n */\nexport const selectPeersScreenSharing = createSelector(selectPeersMap, selectTracksMap, (peersMap, tracksMap) => {\n  const videoPeers = [];\n  const audioPeers = [];\n  for (const peerID in peersMap) {\n    const peer = peersMap[peerID];\n    const { video, audio } = getScreenSharesByPeer(tracksMap, peer);\n    if (video) {\n      videoPeers.push(peer);\n    } else if (audio) {\n      audioPeers.push(peer);\n    }\n  }\n  return videoPeers.concat(audioPeers);\n});\n\nexport const selectPeerSharingVideoPlaylist = createSelector(selectPeersMap, selectTracksMap, (peersMap, tracksMap) => {\n  for (const trackId in tracksMap) {\n    const track = tracksMap[trackId];\n    if (isVideoPlaylist(track) && isVideo(track) && track.peerId) {\n      return peersMap[track.peerId];\n    }\n  }\n  return undefined;\n});\n\nexport const selectPeerSharingAudioPlaylist = createSelector(selectPeersMap, selectTracksMap, (peersMap, tracksMap) => {\n  for (const trackId in tracksMap) {\n    const track = tracksMap[trackId];\n    if (isAudioPlaylist(track) && track.peerId) {\n      return peersMap[track.peerId];\n    }\n  }\n  return undefined;\n});\n\n/**\n * Select an array of tracks that have been degraded(receiving lower video quality/no video) due to bad network locally.\n */\nexport const selectDegradedTracks = createSelector(selectTracks, tracks =>\n  (tracks as HMSVideoTrack[]).filter(isDegraded),\n);\n\n/**\n * Select the number of messages(sent and received).\n */\nexport const selectHMSMessagesCount = createSelector(selectMessageIDsInOrder, messageIDs => messageIDs.length);\n\n/**\n * Select the number of unread messages.\n */\nexport const selectUnreadHMSMessagesCount = createSelector(selectMessagesMap, messages => {\n  return Object.values(messages).filter(m => !m.read).length;\n});\n\n/**\n * Select an array of messages in the room(sent and received).\n */\nexport const selectHMSMessages = createSelector(selectMessageIDsInOrder, selectMessagesMap, (msgIDs, msgMap) => {\n  const messages: HMSMessage[] = [];\n  msgIDs.forEach(msgId => {\n    messages.push(msgMap[msgId]);\n  });\n  return messages;\n});\n\n/**\n * Select the current state of the room.\n */\nexport const selectRoomState = createSelector([selectRoom], room => room && room.roomState);\n\n/**\n * Select a boolean denoting whether the room is in Preview state.\n */\nexport const selectIsInPreview = createSelector(selectRoomState, roomState => roomState === HMSRoomState.Preview);\n\nexport const selectRoomStarted = createSelector(selectRoom, room => room.roomState !== HMSRoomState.Disconnected);\n\n/**\n * Select available roles in the room as a map between the role name and {@link HMSRole} object.\n */\nexport const selectRolesMap = (store: HMSStore): Record<string, HMSRole> => {\n  return store.roles;\n};\n\n/**\n * Select an array of names of available roles in the room.\n */\nexport const selectAvailableRoleNames = createSelector([selectRolesMap], rolesMap => Object.keys(rolesMap));\n\n/**\n * Select the {@link HMSRole} object of your local peer.\n */\nexport const selectLocalPeerRole = createSelector([selectLocalPeer, selectRolesMap], (localPeer, rolesMap) =>\n  localPeer?.roleName ? rolesMap[localPeer.roleName] : null,\n);\n\nexport const selectPreviewRoleName = (store: HMSStore) => store.preview?.asRole;\n\n/**\n * Select the {@link HMSRole} used for preview.\n *\n */\nexport const selectPreviewRole = createSelector([selectPreviewRoleName, selectRolesMap], (roleName, rolesMap) =>\n  roleName ? rolesMap[roleName] : null,\n);\n\n/**\n * Select a boolean denoting whether if your local peer is allowed to subscribe to any other role.\n */\nexport const selectIsAllowedToSubscribe = createSelector([selectLocalPeerRole], (role): boolean => {\n  if (!role?.subscribeParams?.subscribeToRoles) {\n    return false;\n  }\n  return role.subscribeParams.subscribeToRoles.length > 0;\n});\n\n/**\n * Select the permissions which determine what actions the local peer can do.\n */\nexport const selectPermissions = createSelector(selectLocalPeerRole, role => role?.permissions);\nexport const selectRecordingState = createSelector(selectRoom, room => room.recording);\nexport const selectRTMPState = createSelector(selectRoom, room => room.rtmp);\nexport const selectHLSState = createSelector(selectRoom, room => room.hls);\nexport const selectSessionId = createSelector(selectRoom, room => room.sessionId);\nexport const selectRoomStartTime = createSelector(selectRoom, room => room.startedAt);\nexport const selectTemplateAppData = (store: HMSStore) => store.templateAppData;\n/** @deprecated - use `selectSessionStore` instead */\nexport const selectSessionMetadata = (store: HMSStore) => store.sessionMetadata;\n", "import {\n  HMSPeer,\n  HMSPublishAllowed,\n  HMSRole,\n  HMSScreenAudioTrack,\n  HMSScreenVideoTrack,\n  HMSStore,\n  HMSTrack,\n  HMSTrackID,\n  HMSVideoTrack,\n} from '../schema';\n\nexport function getScreenSharesByPeer(tracks: Record<HMSTrackID, HMSTrack>, peer?: HMSPeer | null) {\n  let videoTrack = undefined;\n  let audioTrack = undefined;\n  if (peer) {\n    for (const trackID of peer.auxiliaryTracks) {\n      const track = tracks[trackID];\n      if (isScreenShare(track)) {\n        audioTrack = isAudio(track) ? track : audioTrack;\n        videoTrack = isVideo(track) ? track : videoTrack;\n      }\n    }\n  }\n  // to use the proper type, right now it is only used for screenshare.\n  return { video: videoTrack as HMSScreenVideoTrack, audio: audioTrack as HMSScreenAudioTrack };\n}\n\nexport function isAudio(track: HMSTrack | undefined) {\n  return track && track.type === 'audio';\n}\n\nexport function isVideo(track: HMSTrack | undefined) {\n  return track && track.type === 'video';\n}\n\nexport function isScreenShare(track: HMSTrack | undefined) {\n  return track && track.source === 'screen';\n}\n\nexport function isAudioPlaylist(track: HMSTrack | undefined) {\n  return track && track.source === 'audioplaylist';\n}\n\nexport function isVideoPlaylist(track: HMSTrack | undefined) {\n  return track && track.source === 'videoplaylist';\n}\n\nexport function isDegraded(track: HMSVideoTrack) {\n  if (track) {\n    return Boolean(track?.degraded);\n  }\n  return false;\n}\n\nexport function isTrackEnabled(store: HMSStore, trackID?: string) {\n  if (trackID && store.tracks[trackID]) {\n    return store.tracks[trackID].enabled;\n  }\n  return false;\n}\n\n/**\n * Should UI show the video track as enabled\n */\nexport function isTrackDisplayEnabled(store: HMSStore, trackID?: string) {\n  if (trackID && store.tracks[trackID]) {\n    return store.tracks[trackID].displayEnabled;\n  }\n  return false;\n}\n\nexport function isRoleAllowedToPublish(role?: HMSRole | null): HMSPublishAllowed {\n  let video = false,\n    audio = false,\n    screen = false;\n  if (role?.publishParams?.allowed) {\n    video = role.publishParams.allowed.includes('video');\n    audio = role.publishParams.allowed.includes('audio');\n    screen = role.publishParams.allowed.includes('screen');\n  }\n  return {\n    video,\n    audio,\n    screen,\n  };\n}\n", "import { createSelector } from 'reselect';\nimport { HMSPlaylistSelector, HMSPlaylistType, HMSStore } from '../schema';\n\n/**\n * @internal\n */\nconst selectPlaylistMap =\n  (type: HMSPlaylistType = HMSPlaylistType.audio) =>\n  (store: HMSStore) =>\n    store.playlist[type].list;\n\nconst selectPlaylistSelection =\n  (type: HMSPlaylistType = HMSPlaylistType.audio) =>\n  (store: HMSStore) =>\n    store.playlist[type].selection;\n\nconst selectPlaylistProgress =\n  (type: HMSPlaylistType = HMSPlaylistType.audio) =>\n  (store: HMSStore) =>\n    store.playlist[type].progress;\n\nconst selectPlaylistCurrentTime =\n  (type: HMSPlaylistType = HMSPlaylistType.audio) =>\n  (store: HMSStore) =>\n    store.playlist[type].currentTime;\n\nconst selectPlaylistPlaybackRate =\n  (type: HMSPlaylistType = HMSPlaylistType.audio) =>\n  (store: HMSStore) =>\n    store.playlist[type].playbackRate;\n\nconst selectPlaylistVolume =\n  (type: HMSPlaylistType = HMSPlaylistType.audio) =>\n  (store: HMSStore) =>\n    store.playlist[type].volume;\n\n/**\n * Select an array of playlist items.\n */\nconst selectPlaylist = (type: HMSPlaylistType = HMSPlaylistType.audio) =>\n  createSelector(selectPlaylistMap(type), storePlaylist => {\n    return Object.values(storePlaylist);\n  });\n\nconst selectPlaylistSelectedItem = (type: HMSPlaylistType = HMSPlaylistType.audio) =>\n  createSelector(selectPlaylistMap(type), selectPlaylistSelection(type), (storePlaylist, currentSelection) => {\n    if (!currentSelection.id) {\n      return;\n    }\n    return storePlaylist[currentSelection.id];\n  });\n\nexport const selectAudioPlaylist: HMSPlaylistSelector = {\n  selection: selectPlaylistSelection(HMSPlaylistType.audio),\n  progress: selectPlaylistProgress(HMSPlaylistType.audio),\n  currentTime: selectPlaylistCurrentTime(HMSPlaylistType.audio),\n  playbackRate: selectPlaylistPlaybackRate(HMSPlaylistType.audio),\n  volume: selectPlaylistVolume(HMSPlaylistType.audio),\n  list: selectPlaylist(HMSPlaylistType.audio),\n  selectedItem: <any>selectPlaylistSelectedItem(HMSPlaylistType.audio),\n};\n\nexport const selectVideoPlaylist: HMSPlaylistSelector = {\n  selection: selectPlaylistSelection(HMSPlaylistType.video),\n  progress: selectPlaylistProgress(HMSPlaylistType.video),\n  currentTime: selectPlaylistCurrentTime(HMSPlaylistType.video),\n  playbackRate: selectPlaylistPlaybackRate(HMSPlaylistType.video),\n  volume: selectPlaylistVolume(HMSPlaylistType.video),\n  list: selectPlaylist(HMSPlaylistType.video),\n  selectedItem: <any>selectPlaylistSelectedItem(HMSPlaylistType.video),\n};\n", "import { createSelector } from 'reselect';\nimport { byIDCurry } from './common';\nimport {\n  selectFullAppData,\n  selectHMSMessages,\n  selectLocalPeerID,\n  selectPeers,\n  selectPeersMap,\n  selectTracksMap,\n} from './selectors';\nimport {\n  getScreenSharesByPeer,\n  isAudio,\n  isAudioPlaylist,\n  isTrackEnabled,\n  isVideo,\n  isVideoPlaylist,\n} from './selectorUtils';\nimport { HMSLogger } from '../../common/ui-logger';\nimport {\n  HMSAudioTrack,\n  HMSGenericTypes,\n  HMSPeer,\n  HMSPeerID,\n  HMSRoleName,\n  HMSScreenVideoTrack,\n  HMSStore,\n  HMSTrack,\n  HMSTrackID,\n  HMSVideoTrack,\n} from '../schema';\n\nconst selectPeerID = (_store: HMSStore, peerID: HMSPeerID | undefined) => peerID;\nconst selectTrackID = (_store: HMSStore, trackID: HMSTrackID | undefined) => trackID;\nconst selectRoleName = (_store: HMSStore, roleName: HMSRoleName | undefined) => roleName;\nconst selectAppDataKey = (_store: HMSStore, key: string | undefined) => key;\n\nconst selectPeerByIDBare = createSelector([selectPeersMap, selectPeerID], (storePeers, peerID) =>\n  peerID ? storePeers[peerID] : null,\n);\n\nconst selectTrackByIDBare = createSelector([selectTracksMap, selectTrackID], (storeTracks, trackID) =>\n  trackID ? storeTracks[trackID] : null,\n);\n\nconst selectVideoTrackByIDBare = createSelector([selectTracksMap, selectTrackID], (storeTracks, trackID) => {\n  if (!trackID) {\n    return null;\n  }\n  const track = storeTracks[trackID] as HMSVideoTrack | undefined;\n  if (track?.type === 'video') {\n    return track;\n  }\n  return null;\n});\n\nconst selectAudioTrackByIDBare = createSelector([selectTracksMap, selectTrackID], (storeTracks, trackID) => {\n  if (!trackID) {\n    return null;\n  }\n  const track = storeTracks[trackID] as HMSAudioTrack | undefined;\n  if (track?.type === 'audio') {\n    return track;\n  }\n  return null;\n});\n\nconst selectScreenAudioTrackByIDBare = createSelector([selectTracksMap, selectTrackID], (storeTracks, trackID) => {\n  if (!trackID) {\n    return null;\n  }\n  const track = storeTracks[trackID] as HMSAudioTrack | undefined;\n  if (track?.type === 'audio' && track?.source === 'screen') {\n    return track;\n  }\n  return null;\n});\nconst selectScreenVideoTrackByIDBare = createSelector([selectTracksMap, selectTrackID], (storeTracks, trackID) => {\n  if (!trackID) {\n    return null;\n  }\n  const track = storeTracks[trackID] as HMSScreenVideoTrack | undefined;\n  if (track?.type === 'video' && track?.source === 'screen') {\n    return track;\n  }\n  return null;\n});\n\n/**\n * Select the {@link HMSPeer} object given a peer ID.\n */\nexport const selectPeerByID = byIDCurry(selectPeerByIDBare);\n\n/**\n * Select a particular key from ui app data by passed in key.\n * if key is not passed, full data is returned.\n */\nexport const selectAppData = byIDCurry(\n  createSelector([selectFullAppData, selectAppDataKey], (appData, key) => {\n    if (!appData) {\n      return undefined;\n    }\n    if (key) {\n      return appData[key];\n    }\n    return appData;\n  }),\n);\n\n/**\n * Select a particular key from session store by passed in key.\n * if key is not passed, full data is returned.\n */\nexport function selectSessionStore<T extends HMSGenericTypes = { sessionStore: Record<string, any> }>(): (\n  store: HMSStore<T>,\n) => T['sessionStore'] | undefined;\nexport function selectSessionStore<\n  T extends HMSGenericTypes = { sessionStore: Record<string, any> },\n  K extends keyof T['sessionStore'] = keyof T['sessionStore'],\n>(key: K): (store: HMSStore<T>) => T['sessionStore'][K] | undefined;\nexport function selectSessionStore<\n  T extends HMSGenericTypes = { sessionStore: Record<string, any> },\n  K extends keyof T['sessionStore'] = keyof T['sessionStore'],\n>(key?: K) {\n  return (store: HMSStore<T>) => {\n    if (!store.sessionStore) {\n      return undefined;\n    }\n    if (key) {\n      return store.sessionStore[key];\n    }\n    return store.sessionStore;\n  };\n}\n\nexport const selectAppDataByPath = (...keys: string[]) =>\n  createSelector([selectFullAppData], appData => {\n    if (!appData) {\n      return undefined;\n    }\n    if (keys && keys.length > 0) {\n      let value = appData;\n      for (const key of keys) {\n        if (!key) {\n          return value;\n        }\n        value = value?.[key];\n      }\n      return value;\n    }\n    return appData;\n  });\n\n/**\n * Select the name of a {@link HMSPeer} given a peer ID.\n */\nexport const selectPeerNameByID = byIDCurry(createSelector(selectPeerByIDBare, peer => peer?.name));\n\n/**\n * Select the {@link HMSTrack} object given a track ID.\n */\nexport const selectTrackByID = byIDCurry(selectTrackByIDBare);\n\n/**\n * Select the {@link HMSVideoTrack} object given a track ID.\n */\nexport const selectVideoTrackByID = byIDCurry(selectVideoTrackByIDBare);\n\n/**\n * Select the {@link HMSAudioTrack} object given a track ID.\n */\nexport const selectAudioTrackByID = byIDCurry(selectAudioTrackByIDBare);\n\n/**\n * Select the {@link HMSScreenAudioTrack} object given a track ID.\n */\nexport const selectScreenAudioTrackByID = byIDCurry(selectScreenAudioTrackByIDBare);\n\n/**\n * Select the {@link HMSScreenVideoTrack} object given a track ID.\n */\nexport const selectScreenVideoTrackByID = byIDCurry(selectScreenVideoTrackByIDBare);\n\n/**\n * Select the primary video track of a peer given a peer ID.\n */\nexport const selectVideoTrackByPeerID = byIDCurry((store: HMSStore, peerID?: HMSPeerID): HMSVideoTrack | undefined => {\n  const peer = selectPeerByIDBare(store, peerID);\n  if (peer && peer.videoTrack && peer.videoTrack !== '') {\n    return store.tracks[peer.videoTrack] as HMSVideoTrack;\n  }\n  return undefined;\n});\n\n/**\n * Select the primary audio track of a peer given a peer ID.\n */\nexport const selectAudioTrackByPeerID = byIDCurry((store: HMSStore, peerID?: HMSPeerID): HMSAudioTrack | undefined => {\n  const peer = selectPeerByIDBare(store, peerID);\n  if (peer && peer.audioTrack && peer.audioTrack !== '') {\n    return store.tracks[peer.audioTrack] as HMSAudioTrack;\n  }\n  return undefined;\n});\n\n/**\n * Select the camera stream of a peer given a peer ID.\n * This is the primary video track of a peer.\n */\nexport const selectCameraStreamByPeerID = selectVideoTrackByPeerID;\n\n/**\n * Select an array of auxiliary tracks of a peer given a peer ID.\n */\nexport const selectAuxiliaryTracksByPeerID = byIDCurry((store: HMSStore, peerID?: HMSPeerID): HMSTrack[] => {\n  const peer = selectPeerByIDBare(store, peerID);\n  return peer?.auxiliaryTracks.map(trackID => store.tracks[trackID]) || [];\n});\n\nconst selectSpeakerByTrackID = (store: HMSStore, trackID: HMSTrackID | undefined) => {\n  return trackID ? store.speakers[trackID] : null;\n};\n\n/**\n * Select the audio level of a track given a track ID.\n */\nexport const selectTrackAudioByID = byIDCurry(\n  createSelector(selectSpeakerByTrackID, speaker => speaker?.audioLevel || 0),\n);\n\n/**\n * Select speaker object of audioTrack of a peer given a peer ID.\n */\nconst selectSpeakerByPeerID = (store: HMSStore, peerID: HMSPeerID | undefined) => {\n  const peerAudioTrack = selectAudioTrackByPeerID(peerID)(store);\n  return selectSpeakerByTrackID(store, peerAudioTrack?.id);\n};\n\n/**\n * Select audio level of audioTrack of a peer given a peer ID\u00DF.\n */\nexport const selectPeerAudioByID = byIDCurry(\n  createSelector(selectSpeakerByPeerID, speaker => speaker?.audioLevel || 0),\n);\n\nexport const selectConnectionQualityByPeerID = byIDCurry((store: HMSStore, peerID: HMSPeerID | undefined) => {\n  if (peerID) {\n    return store.connectionQualities[peerID];\n  }\n  return undefined;\n});\n\n/**\n * Select the first auxiliary audio track of a peer given a peer ID.\n */\nexport const selectAuxiliaryAudioByPeerID = byIDCurry((store: HMSStore, peerID?: HMSPeerID) => {\n  const peer = selectPeerByIDBare(store, peerID);\n  if (peer) {\n    const trackID = peer?.auxiliaryTracks.find(trackID => isAudio(store.tracks[trackID]));\n    return trackID ? (store.tracks[trackID] as HMSAudioTrack) : undefined;\n  }\n  return undefined;\n});\n\nexport const selectVideoPlaylistVideoTrackByPeerID = byIDCurry(\n  createSelector(selectTracksMap, selectPeerByIDBare, (tracks, peer) => {\n    const trackID = peer?.auxiliaryTracks.find(trackID => {\n      const track = tracks[trackID];\n      return isVideoPlaylist(track) && isVideo(track);\n    });\n    return trackID ? (tracks[trackID] as HMSVideoTrack) : undefined;\n  }),\n);\n\nexport const selectVideoPlaylistAudioTrackByPeerID = byIDCurry(\n  createSelector(selectTracksMap, selectPeerByIDBare, (tracks, peer) => {\n    const trackID = peer?.auxiliaryTracks.find(trackID => {\n      const track = tracks[trackID];\n      return isVideoPlaylist(track) && isAudio(track);\n    });\n    return trackID ? (tracks[trackID] as HMSAudioTrack) : undefined;\n  }),\n);\n\nexport const selectAudioPlaylistTrackByPeerID = byIDCurry(\n  createSelector(selectTracksMap, selectPeerByIDBare, (tracks, peer) => {\n    const trackID = peer?.auxiliaryTracks.find(trackID => {\n      const track = tracks[trackID];\n      return isAudioPlaylist(track) && isAudio(track);\n    });\n    return trackID ? (tracks[trackID] as HMSAudioTrack) : undefined;\n  }),\n);\n\nexport const selectScreenSharesByPeerId = byIDCurry(\n  createSelector(selectTracksMap, selectPeerByIDBare, (tracks, peer) => {\n    return getScreenSharesByPeer(tracks, peer);\n  }),\n);\n\n/**\n * Select the screen share video track of a peer given a peer ID.\n */\nexport const selectScreenShareByPeerID = (id?: string) =>\n  createSelector(selectScreenSharesByPeerId(id), screenshare => {\n    return screenshare.video;\n  });\n\n/**\n * Select the screen share audio track of a peer given a peer ID.\n */\nexport const selectScreenShareAudioByPeerID = (id?: string) =>\n  createSelector(selectScreenSharesByPeerId(id), screenshare => {\n    return screenshare.audio;\n  });\n\n/**\n * Select a boolean denoting whether a peer has unmuted audio and sharing it to other peers.\n */\nexport const selectIsPeerAudioEnabled = byIDCurry((store: HMSStore, peerID?: string) => {\n  const peer = selectPeerByIDBare(store, peerID);\n  return isTrackEnabled(store, peer?.audioTrack);\n});\n\n/**\n * Select a boolean denoting whether a peer has unmuted video and sharing it to other peers.\n */\nexport const selectIsPeerVideoEnabled = byIDCurry((store: HMSStore, peerID?: string) => {\n  const peer = selectPeerByIDBare(store, peerID);\n  return isTrackEnabled(store, peer?.videoTrack);\n});\n\n/**\n * Select a boolean denoting whether you've muted an audio track locally(only for you) given a track ID.\n */\nexport const selectIsAudioLocallyMuted = byIDCurry((store: HMSStore, trackID?: string) => {\n  if (trackID && store.tracks[trackID]) {\n    return (store.tracks[trackID] as HMSAudioTrack).volume === 0;\n  }\n  return undefined;\n});\n\n/**\n * Select a boolean denoting whether you've muted the primary audio track of a peer locally(only for you) given a peer ID.\n */\nexport const selectIsLocallyMutedByPeerID = byIDCurry((store: HMSStore, peerID?: string) => {\n  const peer = selectPeerByIDBare(store, peerID);\n  return selectIsAudioLocallyMuted(peer?.audioTrack)(store);\n});\n\n/**\n * Select a boolean denoting whether you've muted the screen share audio track of a peer locally(only for you) given a peer ID.\n */\nexport const selectIsScreenShareLocallyMutedByPeerID = byIDCurry((store: HMSStore, peerID?: string) => {\n  const track = selectScreenShareAudioByPeerID(peerID)(store);\n  return selectIsAudioLocallyMuted(track?.id)(store);\n});\n\n/**\n * Select the local audio volume of an audio track given a track ID.\n *\n * NOTE: **Volume** of a track is different from **Audio Level** of a track,\n * - Audio Level measures the audio of a track and it comes from 100ms's servers.\n * - Volume is how loud you hear the audio of a track, this is controlled by you at the client side.\n */\nexport const selectAudioTrackVolume = byIDCurry((store: HMSStore, trackID?: string) => {\n  const track = selectTrackByIDBare(store, trackID);\n  if (track) {\n    if (track.type !== 'audio') {\n      HMSLogger.w('Please pass audio track here');\n      return undefined;\n    }\n    return track.volume;\n  }\n  return undefined;\n});\n\n/**\n * Select the local audio volume of the primary audio track of a peer given a peer ID.\n */\nexport const selectAudioVolumeByPeerID = byIDCurry((store: HMSStore, peerID?: string) => {\n  const peer = selectPeerByIDBare(store, peerID);\n  return selectAudioTrackVolume(peer?.audioTrack)(store);\n});\n\n/**\n * Select the local audio volume of the screen share of a peer given a peer ID.\n */\nexport const selectScreenshareAudioVolumeByPeerID = byIDCurry((store: HMSStore, peerID?: string) => {\n  const track = selectScreenShareAudioByPeerID(peerID)(store);\n  return selectAudioTrackVolume(track?.id)(store);\n});\n\n/**\n * Select the current simulcast layer of a track given a track ID.\n */\nexport const selectSimulcastLayerByTrack = byIDCurry((store: HMSStore, trackID?: string) => {\n  const track = selectTrackByIDBare(store, trackID);\n  if (track) {\n    if (track.type !== 'video') {\n      HMSLogger.w('Please pass video track here');\n      return undefined;\n    }\n    return track.layer;\n  }\n  return undefined;\n});\n\nconst selectMessagesByPeerIDInternal = createSelector(\n  [selectHMSMessages, selectLocalPeerID, selectPeerID],\n  (messages, localPeerID, peerID) => {\n    if (!peerID) {\n      return undefined;\n    }\n    return messages.filter(message => {\n      // Broadcast message\n      if (!message.recipientPeer && !message.recipientRoles?.length) {\n        return false;\n      }\n      // if localPeer or peerID is not a sender remove this\n      if (message.sender && ![localPeerID, peerID].includes(message.sender)) {\n        return false;\n      }\n      // at this point we know the sender is one of local or passed in peer, check the recipient side\n      return [localPeerID, peerID].includes(message.recipientPeer!);\n    });\n  },\n);\n\nconst selectMessagesByRoleInternal = createSelector([selectHMSMessages, selectRoleName], (messages, roleName) => {\n  if (!roleName) {\n    return undefined;\n  }\n  return messages.filter(message => {\n    // Not Role message - Broadcast message or Private Peer message\n    if (!message.recipientRoles?.length) {\n      return false;\n    }\n    return message.recipientRoles?.includes(roleName);\n  });\n});\n\nexport const selectBroadcastMessages = createSelector(selectHMSMessages, messages => {\n  return messages.filter(message => {\n    return !message.recipientPeer && !message.recipientRoles?.length;\n  });\n});\n\nconst selectUnreadMessageCountByRole = createSelector([selectMessagesByRoleInternal, selectRoleName], messages => {\n  if (!messages) {\n    return 0;\n  }\n  return messages.filter(m => !m.read).length;\n});\n\nconst selectUnreadMessageCountByPeerID = createSelector([selectMessagesByPeerIDInternal, selectPeerID], messages => {\n  if (!messages) {\n    return 0;\n  }\n  return messages.filter(m => !m.read).length;\n});\n\nexport const selectBroadcastMessagesUnreadCount = createSelector(selectBroadcastMessages, messages => {\n  return messages.filter(m => !m.read).length;\n});\n\nexport const selectMessagesByPeerID = byIDCurry(selectMessagesByPeerIDInternal);\n\nexport const selectMessagesByRole = byIDCurry(selectMessagesByRoleInternal);\n\nexport const selectMessagesUnreadCountByRole = byIDCurry(selectUnreadMessageCountByRole);\nexport const selectMessagesUnreadCountByPeerID = byIDCurry(selectUnreadMessageCountByPeerID);\n\n/**\n * Select an array of peers of a particular role\n * @param role HMSRoleName\n * @returns HMSPeer[]\n */\nexport const selectPeersByRole = (role: HMSRoleName) =>\n  createSelector([selectPeers], peers => {\n    return peers.filter(p => p.roleName === role);\n  });\n\n/**\n * Select an array of peers of a particular role\n * @param roles HMSRoleName[]\n * @returns HMSPeer[]\n */\nexport const selectPeersByRoles = (roles: HMSRoleName[]) =>\n  createSelector([selectPeers], (peers: HMSPeer[]) => {\n    return peers.filter((peer: HMSPeer) => {\n      return peer.roleName ? roles.includes(peer.roleName) : false;\n    });\n  });\n/**\n * Selects the peer metadata for the passed in peer and returns it as JSON. If metadata is not present\n * or conversion to JSON gives an error, an empty object is returned.\n * Please directly use peer.metadata in case the metadata is not JSON by design.\n */\nexport const selectPeerMetadata = (peerId: HMSPeerID) =>\n  createSelector(selectPeerByID(peerId), peer => {\n    try {\n      return peer?.metadata && peer.metadata !== '' ? JSON.parse(peer.metadata) : {};\n    } catch (error) {\n      console.error('cannot parse peer metadata', error);\n      return {};\n    }\n  });\n\nexport const selectPeerName = (peerId: HMSPeerID) => createSelector(selectPeerByID(peerId), peer => peer?.name);\n", "import { HMSStatsStore, HMSStore } from '../schema';\n\nexport type StoreTypes = HMSStore | HMSStatsStore;\n\ntype byIDSelector<S extends StoreTypes, T> = (store: S, id?: string) => T;\n\n/**\n * StoreSelector is a function that takes in {@link HMSStore} as argument\n * and returns a part of the store that is queried using the selector.\n * @typeParam T Part of the store that you wish to query.\n */\nexport type StoreSelector<S extends StoreTypes, T> = (store: S) => T;\n\n/**\n * takes in a normal selector which has store and id as input and curries it to make it easier to use.\n * Before: store.getState((store) => normalSelector(store, peerID))\n * After: store.getState(curriedSelector(peerID))\n */\nexport function byIDCurry<S extends StoreTypes, T>(selector: byIDSelector<S, T>): (id?: string) => StoreSelector<S, T> {\n  return (id?: string) => {\n    return (store: S) => selector(store, id);\n  };\n}\n", "import { HMSLogLevel } from '../core/hmsSDKStore/sdkTypes';\n\nconst HMS_STORE_TAG = 'HMS-Store:';\n\nexport class HMSLogger {\n  static level: HMSLogLevel = HMSLogLevel.VERBOSE;\n\n  static v(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.VERBOSE, tag, ...data);\n  }\n\n  static d(...data: any[]) {\n    this.log(HMSLogLevel.DEBUG, ...data);\n  }\n\n  static i(...data: any[]) {\n    this.log(HMSLogLevel.INFO, ...data);\n  }\n\n  static w(...data: any[]) {\n    this.log(HMSLogLevel.WARN, ...data);\n  }\n\n  static e(...data: any[]) {\n    this.log(HMSLogLevel.ERROR, ...data);\n  }\n\n  static time(mark: string) {\n    this.log(HMSLogLevel.TIME, '[HMSPerformanceTiming]', mark);\n  }\n\n  static timeEnd(mark: string) {\n    this.log(HMSLogLevel.TIMEEND, '[HMSPerformanceTiming]', mark, mark);\n  }\n\n  static cleanUp() {\n    performance.clearMarks();\n    performance.clearMeasures();\n  }\n\n  /* eslint-disable */\n  private static log(level: HMSLogLevel, ...data: any[]) {\n    if (this.level.valueOf() > level.valueOf()) {\n      return;\n    }\n\n    switch (level) {\n      case HMSLogLevel.VERBOSE: {\n        console.log(HMS_STORE_TAG, ...data);\n        break;\n      }\n      case HMSLogLevel.DEBUG: {\n        console.debug(HMS_STORE_TAG, ...data);\n        break;\n      }\n      case HMSLogLevel.INFO: {\n        console.info(HMS_STORE_TAG, ...data);\n        break;\n      }\n      case HMSLogLevel.WARN: {\n        console.warn(HMS_STORE_TAG, ...data);\n        break;\n      }\n      case HMSLogLevel.ERROR: {\n        console.error(HMS_STORE_TAG, ...data);\n        break;\n      }\n      case HMSLogLevel.TIME: {\n        performance.mark(data[1]);\n        break;\n      }\n      case HMSLogLevel.TIMEEND: {\n        const tag = data[0];\n        const mark = data[1];\n        try {\n          const entry = performance.measure(mark, mark);\n          //@ts-ignore\n          this.log(HMSLogLevel.DEBUG, tag, mark, entry?.duration);\n          performance.clearMarks(mark);\n          performance.clearMeasures(mark);\n        } catch (error) {\n          this.log(HMSLogLevel.DEBUG, tag, mark, error);\n        }\n        break;\n      }\n    }\n  }\n}\n", "import { createSelector } from 'reselect';\nimport { HMSRole } from '@100mslive/hms-video';\nimport { selectLocalPeerRole, selectPeersMap, selectPreviewRole, selectRolesMap, selectTracksMap } from './selectors';\nimport { isRoleAllowedToPublish } from './selectorUtils';\nimport { HMSPeer, HMSStore } from '../schema';\n\nexport interface HMSPeerWithMuteStatus {\n  peer: HMSPeer;\n  isAudioEnabled?: boolean;\n}\n\n/**\n * @privateRemarks\n * this is more friendly to UI format, the object in store has only peer id and role name instead of the full objects\n */\nexport interface HMSRoleChangeRequest {\n  requestedBy?: HMSPeer;\n  role: HMSRole;\n  token: string;\n}\n\nexport const selectPeersWithAudioStatus = createSelector([selectPeersMap, selectTracksMap], (peersMap, tracksMap) => {\n  const participants: HMSPeerWithMuteStatus[] = Object.values(peersMap).map(peer => {\n    return {\n      peer: peer,\n      isAudioEnabled: peer.audioTrack ? tracksMap[peer.audioTrack]?.enabled : false,\n    };\n  });\n  return participants;\n});\n\nconst selectRoleChangeStoreRequest = (store: HMSStore) => {\n  return store.roleChangeRequests[0] || null;\n};\n\n/**\n * Select the role change request received for your local peer.\n */\nexport const selectRoleChangeRequest = createSelector(\n  [selectRoleChangeStoreRequest, selectPeersMap, selectRolesMap],\n  (request, peersMap, rolesMap): HMSRoleChangeRequest | null => {\n    if (!request) {\n      return null;\n    }\n    return {\n      requestedBy: request.requestedBy ? peersMap[request.requestedBy] : undefined,\n      role: rolesMap[request.roleName],\n      token: request.token,\n    };\n  },\n);\n\n/**\n * Select what streams is the local peer allowed to publish from video, audio and screenshare.\n */\nexport const selectIsAllowedToPublish = createSelector([selectLocalPeerRole], role => isRoleAllowedToPublish(role));\n\n/**\n * Select what streams is the local peer allowed to preview from video, audio\n */\nexport const selectIsAllowedToPreviewMedia = createSelector([selectPreviewRole], role => isRoleAllowedToPublish(role));\n", "import { createSelector } from 'reselect';\nimport {\n  selectLocalAudioTrackID,\n  selectLocalVideoTrackID,\n  selectPeers,\n  selectRolesMap,\n  selectRoom,\n  selectTracksMap,\n} from './selectors';\nimport { isRoleAllowedToPublish } from './selectorUtils';\nimport { HMSPeer, HMSTrack } from '../schema';\n\nexport const selectRoleByRoleName = (roleName: string) =>\n  createSelector([selectRolesMap], rolesMap => rolesMap[roleName]);\n\nexport const selectIsRoleAllowedToPublish = (roleName: string) => {\n  return createSelector(selectRoleByRoleName(roleName), role => isRoleAllowedToPublish(role));\n};\n\nconst selectLocalVideoPlugins = createSelector([selectLocalVideoTrackID, selectTracksMap], (trackID, tracksMap) => {\n  let track: HMSTrack | null = null;\n  if (trackID) {\n    track = tracksMap[trackID];\n  }\n  return track?.plugins || [];\n});\n\nconst selectLocalAudioPlugins = createSelector([selectLocalAudioTrackID, selectTracksMap], (trackID, tracksMap) => {\n  let track: HMSTrack | null = null;\n  if (trackID) {\n    track = tracksMap[trackID];\n  }\n  return track?.plugins || [];\n});\n\nexport const selectIsLocalVideoPluginPresent = (pluginName: string) => {\n  return createSelector([selectLocalVideoPlugins], plugins => {\n    return plugins.includes(pluginName);\n  });\n};\n\nexport const selectIsLocalAudioPluginPresent = (pluginName: string) => {\n  return createSelector([selectLocalAudioPlugins], plugins => {\n    return plugins.includes(pluginName);\n  });\n};\n\n/**\n * Selects the first peer passing the condition given by the argument predicate function\n *\n * Ex: to select a peer whose metadata has spotlight set to true(assuming peer.metadata is a valid json string), use\n * ```js\n * const spotlightPeer = useHMSStore(selectPeerByCondition(peer => JSON.parse(peer.metadata).spotlight))\n * ```\n */\nexport const selectPeerByCondition = (predicate: (peer: HMSPeer) => boolean) =>\n  createSelector(selectPeers, peers => {\n    return peers.find(predicate);\n  });\n\n/**\n * Selects all peers passing the condition given by the argument predicate function\n *\n * Ex: to select peers with isHandRaised set to true in their metadata(assuming peer.metadata is a valid json string), use\n * ```js\n * const handRaisedPeers = useHMSStore(selectPeersByCondition(peer => JSON.parse(peer.metadata).isHandRaised))\n * ```\n */\nexport const selectPeersByCondition = (predicate: (peer: HMSPeer) => boolean) =>\n  createSelector(selectPeers, peers => {\n    return peers.filter(predicate);\n  });\n\n/**\n * Returns a boolean to indicate if the local peer joined within the past `timeMs` milliseconds.\n *\n * Ex: to know if the local peer joined within the last one second\n * ```js\n * const joinedWithinASecond = useHMSStore(selectDidIJoinWithin(1000));\n * ```\n */\nexport const selectDidIJoinWithin = (timeMs: number) =>\n  createSelector(selectRoom, room => room.joinedAt && Date.now() - room.joinedAt.getTime() <= timeMs);\n", "import {\n  HMSAudioPlugin,\n  HMSAudioTrack as SDKHMSAudioTrack,\n  HMSChangeMultiTrackStateParams as SDKHMSChangeMultiTrackStateParams,\n  HMSChangeMultiTrackStateRequest as SDKHMSChangeMultiTrackStateRequest,\n  HMSChangeTrackStateRequest as SDKHMSChangeTrackStateRequest,\n  HMSException as SDKHMSException,\n  HMSLeaveRoomRequest as SDKHMSLeaveRoomRequest,\n  HMSLocalAudioTrack as SDKHMSLocalAudioTrack,\n  HMSLocalTrack as SDKHMSLocalTrack,\n  HMSLocalVideoTrack as SDKHMSLocalVideoTrack,\n  HMSLogLevel,\n  HMSPluginSupportResult,\n  HMSRemoteTrack as SDKHMSRemoteTrack,\n  HMSRemoteVideoTrack as SDKHMSRemoteVideoTrack,\n  HMSRoleChangeRequest as SDKHMSRoleChangeRequest,\n  HMSScreenShareConfig,\n  HMSSdk,\n  HMSSimulcastLayer,\n  HMSTrack as SDKHMSTrack,\n  HMSVideoPlugin,\n  HMSVideoTrack as SDKHMSVideoTrack,\n  SessionStoreUpdate,\n} from '@100mslive/hms-video';\nimport { PEER_NOTIFICATION_TYPES, TRACK_NOTIFICATION_TYPES } from './common/mapping';\nimport { isRemoteTrack } from './sdkUtils/sdkUtils';\nimport { areArraysEqual, mergeNewPeersInDraft, mergeNewTracksInDraft } from './sdkUtils/storeMergeUtils';\nimport { SDKToHMS } from './adapter';\nimport { HMSNotifications } from './HMSNotifications';\nimport { HMSPlaylist } from './HMSPlaylist';\nimport { HMSSessionStore } from './HMSSessionStore';\nimport { NamedSetState } from './internalTypes';\nimport * as sdkTypes from './sdkTypes';\nimport { HMSLogger } from '../../common/ui-logger';\nimport { BeamSpeakerLabelsLogger } from '../../controller/beam/BeamSpeakerLabelsLogger';\nimport { IHMSActions } from '../IHMSActions';\nimport { IHMSStore } from '../IHMSStore';\nimport {\n  createDefaultStoreState,\n  HMSChangeMultiTrackStateParams,\n  HMSGenericTypes,\n  HMSMediaSettings,\n  HMSMessage,\n  HMSMessageInput,\n  HMSPeer,\n  HMSPeerID,\n  HMSPlaylistType,\n  HMSRoleName,\n  HMSRoomState,\n  HMSStore,\n  HMSTrack,\n  HMSTrackID,\n  HMSTrackSource,\n  HMSVideoTrack,\n  IHMSPlaylistActions,\n  IHMSSessionStoreActions,\n} from '../schema';\nimport {\n  HMSRoleChangeRequest,\n  selectHMSMessagesCount,\n  selectIsConnectedToRoom,\n  selectIsLocalScreenShared,\n  selectIsLocalVideoDisplayEnabled,\n  selectIsLocalVideoEnabled,\n  selectLocalAudioTrackID,\n  selectLocalMediaSettings,\n  selectLocalPeer,\n  selectLocalTrackIDs,\n  selectLocalVideoTrackID,\n  selectPeerByID,\n  selectPeersMap,\n  selectPermissions,\n  selectRolesMap,\n  selectRoomState,\n  selectTrackByID,\n  selectTracksMap,\n  selectVideoTrackByID,\n} from '../selectors';\n\n// import { ActionBatcher } from './sdkUtils/ActionBatcher';\n\n/**\n * This class implements the IHMSActions interface for 100ms SDK. It connects with SDK\n * and takes control of data management by letting every action pass through it. The\n * passed in store is ensured to be the single source of truth reflecting current\n * room related data at any point in time.\n *\n * @privateRemarks\n * Things to keep in mind while updating store -\n * 1. Treat setState as an atomic operation, if an action results in multiple changes,\n *    the changes should all happen within single setState function.\n * 2. While updating the state it's very important to not update the reference if\n *    something is unchanged. Copy data in same reference object don't assign new\n *    object.\n * 3. Mental Model(1) - Actions from backend -> Listeners of this class -> update store -> views update themselves\n *    eg. for this - peer added, remote muted etc.\n * 4. Mental Model(2) - Actions from local -> View calls actions -> update store -> views update themselves\n *    eg. local track enabled, join, leave etc.\n * 5. State is immutable, a new copy with new references is created when there is a change,\n *    if you try to modify state outside of setState, there'll be an error.\n */\nexport class HMSSDKActions<T extends HMSGenericTypes = { sessionStore: Record<string, any> }>\n  implements IHMSActions<T>\n{\n  private hmsSDKTracks: Record<string, SDKHMSTrack> = {};\n  private hmsSDKPeers: Record<string, sdkTypes.HMSPeer> = {};\n  private readonly sdk: HMSSdk;\n  private readonly store: IHMSStore<T>;\n  private isRoomJoinCalled = false;\n  private hmsNotifications: HMSNotifications<T>;\n  private ignoredMessageTypes: string[] = [];\n  // private actionBatcher: ActionBatcher;\n  audioPlaylist!: IHMSPlaylistActions;\n  videoPlaylist!: IHMSPlaylistActions;\n  sessionStore: IHMSSessionStoreActions<T['sessionStore']>;\n  private beamSpeakerLabelsLogger?: BeamSpeakerLabelsLogger<T>;\n\n  constructor(store: IHMSStore<T>, sdk: HMSSdk, notificationManager: HMSNotifications<T>) {\n    this.store = store;\n    this.sdk = sdk;\n    this.hmsNotifications = notificationManager;\n\n    this.sessionStore = new HMSSessionStore<T['sessionStore']>(this.sdk, this.setSessionStoreValueLocally.bind(this));\n\n    // this.actionBatcher = new ActionBatcher(store);\n  }\n\n  async refreshDevices() {\n    await this.sdk.refreshDevices();\n  }\n\n  async unblockAudio() {\n    await this.sdk.getAudioOutput().unblockAutoplay();\n  }\n\n  async setVolume(value: number, trackId?: HMSTrackID) {\n    if (trackId) {\n      await this.setTrackVolume(value, trackId);\n    } else {\n      await this.sdk.getAudioOutput().setVolume(value);\n      this.syncRoomState('setOutputVolume');\n    }\n  }\n\n  async setAudioOutputDevice(deviceId: string): Promise<void> {\n    const deviceInfo = await this.sdk.getAudioOutput().setDevice(deviceId);\n    if (deviceInfo) {\n      this.setState(draftStore => {\n        draftStore.settings.audioOutputDeviceId = deviceId;\n      }, 'setAudioOutputDevice');\n    }\n  }\n\n  async setPreferredLayer(trackId: string, layer: sdkTypes.HMSPreferredSimulcastLayer) {\n    const track = this.hmsSDKTracks[trackId];\n    if (track) {\n      if (track instanceof SDKHMSRemoteVideoTrack) {\n        //@ts-ignore\n        if (layer === HMSSimulcastLayer.NONE) {\n          HMSLogger.d(`layer ${HMSSimulcastLayer.NONE} will be ignored`);\n          return;\n        }\n        const alreadyInSameState = this.store.getState(selectVideoTrackByID(trackId))?.preferredLayer === layer;\n        if (alreadyInSameState) {\n          HMSLogger.d(`preferred layer is already ${layer}`);\n          return;\n        }\n        this.setState(draftStore => {\n          const track = draftStore.tracks[trackId] as HMSVideoTrack;\n          if (track) {\n            track.preferredLayer = layer;\n          }\n        }, 'setPreferredLayer');\n        await track.setPreferredLayer(layer);\n      } else {\n        HMSLogger.d(`track ${trackId} is not a remote video track`);\n      }\n    } else {\n      this.logPossibleInconsistency(`track ${trackId} not present, unable to set preffer layer`);\n    }\n  }\n\n  getAuthTokenByRoomCode(\n    tokenRequest: sdkTypes.TokenRequest,\n    tokenRequestOptions?: sdkTypes.TokenRequestOptions,\n  ): Promise<string> {\n    return this.sdk.getAuthTokenByRoomCode(tokenRequest, tokenRequestOptions);\n  }\n\n  async preview(config: sdkTypes.HMSPreviewConfig) {\n    if (this.isRoomJoinCalled) {\n      this.logPossibleInconsistency('attempting to call preview after join was called');\n      return; // ignore\n    }\n    const roomState = this.store.getState(selectRoomState);\n    if (roomState === HMSRoomState.Preview || roomState === HMSRoomState.Connecting) {\n      this.logPossibleInconsistency('attempting to call preview while room is in preview/connecting');\n      return;\n    }\n\n    try {\n      this.setState(store => {\n        store.room.roomState = HMSRoomState.Connecting;\n      }, 'connecting');\n      await this.sdkPreviewWithListeners(config);\n    } catch (err) {\n      HMSLogger.e('Cannot show preview. Failed to connect to room - ', err);\n      throw err;\n    }\n  }\n\n  async join(config: sdkTypes.HMSConfig) {\n    if (this.isRoomJoinCalled) {\n      this.logPossibleInconsistency('room join is called again');\n      return; // ignore\n    }\n    try {\n      this.isRoomJoinCalled = true;\n      this.setState(store => {\n        store.room.roomState = HMSRoomState.Connecting;\n      }, 'join');\n      await this.sdkJoinWithListeners(config);\n    } catch (err) {\n      this.isRoomJoinCalled = false; // so it can be called again if needed\n      HMSLogger.e('Failed to connect to room - ', err);\n      throw err;\n    }\n  }\n\n  async leave() {\n    const isConnectedToRoom = this.store.getState(selectIsConnectedToRoom);\n    let notifyServer = true;\n    if (!isConnectedToRoom) {\n      notifyServer = false;\n      this.logPossibleInconsistency('room leave is called when no room is connected');\n    }\n    const currentRoomState = this.store.getState(selectRoomState);\n    this.setState(store => {\n      store.room.roomState = HMSRoomState.Disconnecting;\n    }, 'leaving');\n    return this.sdk\n      .leave(notifyServer)\n      .then(() => {\n        this.resetState('leave');\n        if (this.beamSpeakerLabelsLogger) {\n          this.beamSpeakerLabelsLogger.stop().catch(HMSLogger.e);\n        }\n        HMSLogger.i('left room');\n      })\n      .catch(err => {\n        HMSLogger.e('error in leaving room - ', err);\n        this.setState(store => {\n          store.room.roomState = currentRoomState;\n        }, 'revertLeave');\n      });\n  }\n\n  async setScreenShareEnabled(enabled: boolean, config?: HMSScreenShareConfig) {\n    // TODO: remove this, purely for backward compatibility\n    if (typeof config === 'boolean') {\n      config = { audioOnly: config };\n    }\n    try {\n      if (enabled) {\n        await this.startScreenShare(config);\n      } else {\n        await this.stopScreenShare();\n      }\n    } catch (error) {\n      this.hmsNotifications.sendError(SDKToHMS.convertException(error as SDKHMSException));\n      throw error;\n    }\n  }\n\n  async addTrack(track: MediaStreamTrack, type: HMSTrackSource = 'regular') {\n    await this.sdk.addTrack(track, type);\n    this.syncRoomState('addTrack');\n  }\n\n  async removeTrack(trackId: string) {\n    await this.sdk.removeTrack(trackId);\n    this.syncRoomState('removeTrack');\n  }\n\n  async setLocalAudioEnabled(enabled: boolean) {\n    const trackID = this.store.getState(selectLocalAudioTrackID);\n    if (trackID) {\n      await this.setEnabledTrack(trackID, enabled);\n    }\n  }\n\n  async setLocalVideoEnabled(enabled: boolean) {\n    const trackID = this.store.getState(selectLocalVideoTrackID);\n    if (trackID) {\n      await this.setEnabledTrack(trackID, enabled);\n    }\n  }\n\n  async setEnabledTrack(trackID: string, enabled: boolean) {\n    // if mute/unmute is clicked multiple times for same operation, ignore repeated ones\n    const alreadyInSameState = this.store.getState().tracks[trackID]?.enabled === enabled;\n    if (alreadyInSameState) {\n      // it could also be a case of possible inconsistency where UI state is out of sync with truth\n      this.logPossibleInconsistency(`local track[${trackID}] enabled state - ${enabled}`);\n      return;\n    }\n    this.setState(store => {\n      // show on UI immediately\n      if (!store.tracks[trackID]) {\n        this.logPossibleInconsistency('track id not found for setEnabled');\n      } else {\n        store.tracks[trackID].displayEnabled = enabled;\n      }\n    }, 'displayEnabled');\n    try {\n      await this.setEnabledSDKTrack(trackID, enabled); // do the operation\n      this.syncRoomState('setEnabled');\n    } catch (err) {\n      // rollback on failure\n      this.setState(store => {\n        store.tracks[trackID].displayEnabled = !enabled;\n      }, 'rollbackDisplayEnabled');\n      this.hmsNotifications.sendError(SDKToHMS.convertException(err as SDKHMSException));\n      throw err;\n    }\n    const type = enabled ? sdkTypes.HMSTrackUpdate.TRACK_UNMUTED : sdkTypes.HMSTrackUpdate.TRACK_MUTED;\n    this.hmsNotifications.sendTrackUpdate(type, trackID);\n  }\n\n  async setAudioSettings(settings: Partial<sdkTypes.HMSAudioTrackSettings>) {\n    const trackID = this.store.getState(selectLocalAudioTrackID);\n    if (trackID) {\n      await this.setSDKLocalAudioTrackSettings(trackID, settings);\n      this.syncRoomState('setAudioSettings');\n    }\n  }\n\n  async setVideoSettings(settings: Partial<sdkTypes.HMSVideoTrackSettings>) {\n    const trackID = this.store.getState(selectLocalVideoTrackID);\n    if (trackID) {\n      await this.setSDKLocalVideoTrackSettings(trackID, settings);\n      this.syncRoomState('setVideoSettings');\n    }\n  }\n\n  async switchCamera(): Promise<void> {\n    const trackID = this.store.getState(selectLocalVideoTrackID);\n    if (trackID) {\n      const sdkTrack = this.hmsSDKTracks[trackID] as SDKHMSLocalVideoTrack;\n      if (sdkTrack) {\n        await sdkTrack.switchCamera();\n        this.syncRoomState('switchCamera');\n      }\n    }\n  }\n\n  sendMessage(message: string) {\n    this.sendBroadcastMessage(message);\n  }\n\n  async sendBroadcastMessage(message: string, type?: string) {\n    const sdkMessage = await this.sdk.sendBroadcastMessage(message, type);\n    this.updateMessageInStore(sdkMessage, { message, type });\n  }\n\n  async sendGroupMessage(message: string, roles: string[], type?: string) {\n    const storeRoles = this.store.getState(selectRolesMap);\n    const hmsRoles = roles.map(roleName => {\n      return storeRoles[roleName];\n    });\n    const sdkMessage = await this.sdk.sendGroupMessage(message, hmsRoles, type);\n    this.updateMessageInStore(sdkMessage, { message, recipientRoles: roles, type });\n  }\n\n  async sendDirectMessage(message: string, peerID: string, type?: string) {\n    const hmsPeer = this.hmsSDKPeers[peerID];\n    const sdkMessage = await this.sdk.sendDirectMessage(message, hmsPeer, type);\n    this.updateMessageInStore(sdkMessage, { message, recipientPeer: hmsPeer.peerId, type });\n  }\n\n  private updateMessageInStore(sdkMessage: sdkTypes.HMSMessage | void, messageInput: string | HMSMessageInput) {\n    if (!sdkMessage) {\n      HMSLogger.w('sendMessage', 'Failed to send message', messageInput);\n      throw Error(`sendMessage Failed - ${JSON.stringify(messageInput)}`);\n    }\n    const hmsMessage = SDKToHMS.convertMessage(sdkMessage) as HMSMessage;\n    hmsMessage.read = true;\n    hmsMessage.senderName = 'You';\n    hmsMessage.ignored = this.ignoredMessageTypes.includes(hmsMessage.type);\n    this.putMessageInStore(hmsMessage);\n    return hmsMessage;\n  }\n\n  setMessageRead(readStatus: boolean, messageId?: string) {\n    this.setState(store => {\n      if (messageId) {\n        if (!store.messages.byID[messageId]) {\n          this.logPossibleInconsistency('no message with id is found');\n        } else {\n          store.messages.byID[messageId].read = readStatus;\n        }\n      } else {\n        store.messages.allIDs.forEach((id: string) => {\n          store.messages.byID[id].read = readStatus;\n        });\n      }\n    }, 'setMessageRead');\n  }\n\n  async attachVideo(trackID: string, videoElement: HTMLVideoElement) {\n    if (this.localAndVideoUnmuting(trackID)) {\n      // wait till video unmute has finished\n      return new Promise<void>(resolve => {\n        const unsub = this.store.subscribe(async enabled => {\n          if (enabled) {\n            await this.attachVideoInternal(trackID, videoElement);\n            unsub();\n            resolve();\n          }\n        }, selectIsLocalVideoEnabled);\n      });\n    } else {\n      await this.attachVideoInternal(trackID, videoElement);\n    }\n  }\n\n  async detachVideo(trackID: string, videoElement: HTMLVideoElement) {\n    const sdkTrack = this.hmsSDKTracks[trackID];\n    if (sdkTrack?.type === 'video') {\n      await this.sdk.detachVideo(sdkTrack as SDKHMSVideoTrack, videoElement);\n    } else {\n      if (videoElement) {\n        videoElement.srcObject = null; // so chrome can clean up\n      }\n      HMSLogger.d('possible inconsistency detected - no video track found to remove sink');\n    }\n  }\n\n  async addPluginToVideoTrack(plugin: HMSVideoPlugin, pluginFrameRate?: number): Promise<void> {\n    return this.addRemoveVideoPlugin(plugin, 'add', pluginFrameRate);\n  }\n  async addPluginToAudioTrack(plugin: HMSAudioPlugin): Promise<void> {\n    return this.addRemoveAudioPlugin(plugin, 'add');\n  }\n\n  validateVideoPluginSupport(plugin: HMSVideoPlugin): HMSPluginSupportResult {\n    let result = {} as HMSPluginSupportResult;\n    result.isSupported = false; //Setting default to false\n    if (!plugin) {\n      HMSLogger.w('no plugin passed in for checking support');\n      result.errMsg = 'no plugin passed in for checking support';\n      return result;\n    }\n    const trackID = this.store.getState(selectLocalVideoTrackID);\n    if (!trackID) {\n      HMSLogger.w('video Track not added to local peer yet');\n      result.errMsg = 'call this function only after local peer has video track';\n      return result;\n    }\n    const sdkTrack = this.hmsSDKTracks[trackID];\n    if (sdkTrack) {\n      result = (sdkTrack as SDKHMSLocalVideoTrack).validatePlugin(plugin);\n    } else {\n      HMSLogger.w(`track ${trackID} not present, unable to validate plugin`);\n      result.errMsg = `track ${trackID} not present, unable to validate plugin`;\n    }\n\n    return result;\n  }\n\n  validateAudioPluginSupport(plugin: HMSAudioPlugin): HMSPluginSupportResult {\n    let result = {} as HMSPluginSupportResult;\n    result.isSupported = false; //Setting default to false\n    if (!plugin) {\n      HMSLogger.w('no plugin passed in for checking support\"');\n      result.errMsg = 'no plugin passed in for checking support\"';\n      return result;\n    }\n    const trackID = this.store.getState(selectLocalAudioTrackID);\n    if (!trackID) {\n      HMSLogger.w('audio track not added to local peer yet');\n      result.errMsg = 'call this function only after local peer has audio track';\n      return result;\n    }\n    const sdkTrack = this.hmsSDKTracks[trackID];\n    if (sdkTrack) {\n      result = (sdkTrack as SDKHMSLocalAudioTrack).validatePlugin(plugin);\n    } else {\n      HMSLogger.w(`track ${trackID} not present, unable to validate plugin`);\n      result.errMsg = `track ${trackID} not present, unable to validate plugin`;\n    }\n\n    return result;\n  }\n\n  async removePluginFromVideoTrack(plugin: HMSVideoPlugin): Promise<void> {\n    return this.addRemoveVideoPlugin(plugin, 'remove');\n  }\n  async removePluginFromAudioTrack(plugin: HMSAudioPlugin): Promise<void> {\n    return this.addRemoveAudioPlugin(plugin, 'remove');\n  }\n\n  async changeRole(forPeerId: string, toRole: string, force = false) {\n    const peer = this.hmsSDKPeers[forPeerId];\n    if (!peer) {\n      this.logPossibleInconsistency(`Unknown peer ID given ${forPeerId} for changerole`);\n      return;\n    }\n\n    await this.sdk.changeRoleOfPeer(peer, toRole, force);\n  }\n\n  async changeRoleOfPeer(forPeerId: string, toRole: string, force = false) {\n    const peer = this.hmsSDKPeers[forPeerId];\n    if (!peer) {\n      this.logPossibleInconsistency(`Unknown peer ID given ${forPeerId} for changerole`);\n      return;\n    }\n\n    await this.sdk.changeRoleOfPeer(peer, toRole, force);\n  }\n\n  async changeRoleOfPeersWithRoles(roles: HMSRoleName[], toRole: HMSRoleName) {\n    const rolesToBeChanged = this.sdk.getRoles().filter(role => roles.includes(role.name));\n    await this.sdk.changeRoleOfPeersWithRoles(rolesToBeChanged, toRole);\n  }\n\n  // TODO: separate out role related things in another file\n  async acceptChangeRole(request: HMSRoleChangeRequest) {\n    const sdkPeer: sdkTypes.HMSPeer | undefined = request.requestedBy\n      ? this.hmsSDKPeers[request.requestedBy.id]\n      : undefined;\n    if (!sdkPeer) {\n      HMSLogger.w(`peer for which role change is requested no longer available - ${request.requestedBy}`);\n    }\n    const sdkRequest = {\n      requestedBy: sdkPeer,\n      role: request.role,\n      token: request.token,\n    };\n    // TODO: hotfix for HMS-3639. Needs a better solution\n    await this.sdk.acceptChangeRole(sdkRequest);\n    this.removeRoleChangeRequest(request);\n  }\n\n  initAppData(appData: Record<string, any>) {\n    this.setState(store => {\n      store.appData = appData;\n    }, 'initAppData');\n  }\n\n  setAppData(key: string, value: any, merge?: boolean) {\n    const isValueObject = value?.constructor.name === 'Object';\n    this.setState(store => {\n      if (store.appData) {\n        if (merge && isValueObject) {\n          Object.assign(store.appData[key], value);\n        } else {\n          store.appData[key] = value;\n        }\n      } else {\n        const newAppData = {\n          [key]: value,\n        };\n        store.appData = newAppData;\n      }\n    }, `setAppData-${key}`);\n  }\n\n  /**\n   * @privateRemarks\n   * there is no corresponding sdk method for rejecting change role but as the store also maintains the full\n   * state of current pending requests, this method allows it to clean up when the request is rejected\n   */\n  rejectChangeRole(request: HMSRoleChangeRequest) {\n    this.removeRoleChangeRequest(request);\n  }\n\n  async endRoom(lock: boolean, reason: string) {\n    const permissions = this.store.getState(selectPermissions);\n    if (!permissions?.endRoom) {\n      HMSLogger.w('You are not allowed to perform this action - endRoom');\n      return;\n    }\n    const currentRoomState = this.store.getState(selectRoomState);\n    this.setState(store => {\n      store.room.roomState = HMSRoomState.Disconnecting;\n    }, 'endingRoom');\n    try {\n      await this.sdk.endRoom(lock, reason);\n      this.resetState('endRoom');\n    } catch (err) {\n      HMSLogger.e('error in ending room - ', err);\n      this.setState(store => {\n        store.room.roomState = currentRoomState;\n      }, 'revertEndRoom');\n    }\n  }\n\n  async removePeer(peerID: string, reason: string) {\n    const peer = this.hmsSDKPeers[peerID];\n    if (peer && !peer.isLocal) {\n      await this.sdk.removePeer(peer as sdkTypes.HMSRemotePeer, reason);\n    } else {\n      this.logPossibleInconsistency(`No remote peer found for peerID - ${peerID}`);\n      return;\n    }\n  }\n\n  async startRTMPOrRecording(params: sdkTypes.RTMPRecordingConfig) {\n    await this.sdk.startRTMPOrRecording(params);\n  }\n\n  async stopRTMPAndRecording() {\n    await this.sdk.stopRTMPAndRecording();\n  }\n\n  async startHLSStreaming(params?: sdkTypes.HLSConfig) {\n    await this.sdk.startHLSStreaming(params);\n  }\n\n  async stopHLSStreaming(params?: sdkTypes.HLSConfig): Promise<void> {\n    await this.sdk.stopHLSStreaming(params);\n  }\n\n  async sendHLSTimedMetadata(metadataList: sdkTypes.HLSTimedMetadata[]): Promise<void> {\n    await this.sdk.sendHLSTimedMetadata(metadataList);\n  }\n  async changeName(name: string) {\n    await this.sdk.changeName(name);\n  }\n\n  async changeMetadata(metadata: string | any) {\n    if (typeof metadata !== 'string') {\n      metadata = JSON.stringify(metadata);\n    }\n    await this.sdk.changeMetadata(metadata);\n  }\n\n  async setSessionMetadata(metadata: any) {\n    await this.sdk.setSessionMetadata(metadata);\n    this.setState(draftStore => {\n      draftStore.sessionMetadata = metadata;\n    }, 'setSessionMetadata');\n    this.setSessionStoreValueLocally({ key: 'default', value: metadata }, 'setSessionMetadata');\n  }\n\n  async populateSessionMetadata(): Promise<void> {\n    const metadata = await this.sdk.getSessionMetadata();\n    this.setState(draftStore => {\n      draftStore.sessionMetadata = metadata;\n    }, 'populateSessionMetadata');\n    this.setSessionStoreValueLocally({ key: 'default', value: metadata }, 'populateSessionmetadata');\n  }\n\n  async setRemoteTrackEnabled(trackID: HMSTrackID | HMSTrackID[], enabled: boolean) {\n    if (typeof trackID === 'string') {\n      const track = this.hmsSDKTracks[trackID];\n      if (track && isRemoteTrack(track)) {\n        await this.sdk.changeTrackState(track as SDKHMSRemoteTrack, enabled);\n      } else {\n        this.logPossibleInconsistency(`No remote track with ID ${trackID} found for change track state`);\n      }\n    } else if (Array.isArray(trackID)) {\n      trackID.forEach(id => this.setRemoteTrackEnabled(id, enabled));\n    }\n  }\n\n  async setRemoteTracksEnabled(params: HMSChangeMultiTrackStateParams) {\n    const sdkRequest: SDKHMSChangeMultiTrackStateParams = {\n      enabled: params.enabled,\n      type: params.type,\n      source: params.source,\n    };\n    if (params.roles) {\n      const rolesMap = this.store.getState(selectRolesMap);\n      sdkRequest.roles = params.roles.map(role => rolesMap[role]);\n    }\n    await this.sdk.changeMultiTrackState(sdkRequest);\n  }\n\n  setLogLevel(level: HMSLogLevel) {\n    HMSLogger.level = level;\n    this.sdk.setLogLevel(level);\n  }\n\n  setFrameworkInfo(frameworkInfo: sdkTypes.HMSFrameworkInfo) {\n    this.sdk.setFrameworkInfo(frameworkInfo);\n  }\n\n  ignoreMessageTypes(msgTypes: string[], replace = false) {\n    if (replace) {\n      this.ignoredMessageTypes = msgTypes;\n    } else {\n      for (const msgType of msgTypes) {\n        if (!this.ignoredMessageTypes.includes(msgType)) {\n          this.ignoredMessageTypes.push(msgType);\n        }\n      }\n    }\n  }\n\n  async enableBeamSpeakerLabelsLogging() {\n    if (!this.beamSpeakerLabelsLogger) {\n      HMSLogger.i('enabling beam speaker labels logging');\n      this.beamSpeakerLabelsLogger = new BeamSpeakerLabelsLogger(this.store, this);\n      await this.beamSpeakerLabelsLogger.start();\n    }\n  }\n\n  private resetState(reason = 'resetState') {\n    this.isRoomJoinCalled = false;\n    this.hmsSDKTracks = {};\n    HMSLogger.cleanUp();\n    this.setState(store => {\n      Object.assign(store, createDefaultStoreState());\n    }, reason);\n  }\n\n  private async sdkJoinWithListeners(config: sdkTypes.HMSConfig) {\n    await this.sdk.join(config, {\n      onJoin: this.onJoin.bind(this),\n      onRoomUpdate: this.onRoomUpdate.bind(this),\n      onPeerUpdate: this.onPeerUpdate.bind(this),\n      onTrackUpdate: this.onTrackUpdate.bind(this),\n      onMessageReceived: this.onMessageReceived.bind(this),\n      onError: this.onError.bind(this),\n      onReconnected: this.onReconnected.bind(this),\n      onReconnecting: this.onReconnecting.bind(this),\n      onRoleChangeRequest: this.onRoleChangeRequest.bind(this),\n      onRoleUpdate: this.onRoleUpdate.bind(this),\n      onDeviceChange: this.onDeviceChange.bind(this),\n      onChangeTrackStateRequest: this.onChangeTrackStateRequest.bind(this),\n      onChangeMultiTrackStateRequest: this.onChangeMultiTrackStateRequest.bind(this),\n      onRemovedFromRoom: this.onRemovedFromRoom.bind(this),\n      onNetworkQuality: this.onNetworkQuality.bind(this),\n      onSessionStoreUpdate: this.onSessionStoreUpdate.bind(this),\n    });\n    this.sdk.addAudioListener({\n      onAudioLevelUpdate: this.onAudioLevelUpdate.bind(this),\n    });\n    this.sdk.addConnectionQualityListener({\n      onConnectionQualityUpdate: this.onConnectionQualityUpdate.bind(this),\n    });\n  }\n\n  private onRemovedFromRoom(request: SDKHMSLeaveRoomRequest) {\n    const requestedBy = this.store.getState(selectPeerByID(request.requestedBy?.peerId));\n    this.hmsNotifications.sendLeaveRoom({\n      ...request,\n      requestedBy: requestedBy || undefined,\n    });\n    const action = request.roomEnded || !requestedBy ? 'roomEnded' : 'removedFromRoom';\n    HMSLogger.i(`resetting state after peer removed ${action}`, request);\n    this.resetState(action);\n  }\n\n  private onDeviceChange(event: sdkTypes.HMSDeviceChangeEvent) {\n    const devices = event.devices;\n    if (!devices) {\n      return;\n    }\n    const localPeer = this.store.getState(selectLocalPeer);\n    this.setState(store => {\n      if (!areArraysEqual(store.devices.audioInput, devices.audioInput)) {\n        store.devices.audioInput = devices.audioInput;\n      }\n      if (!areArraysEqual(store.devices.videoInput, devices.videoInput)) {\n        store.devices.videoInput = devices.videoInput;\n      }\n      if (!areArraysEqual(store.devices.audioOutput, devices.audioOutput)) {\n        store.devices.audioOutput = devices.audioOutput;\n      }\n      if (localPeer?.id && this.hmsSDKPeers[localPeer.id]) {\n        Object.assign(store.settings, this.getMediaSettings(this.hmsSDKPeers[localPeer.id]));\n      }\n    }, 'deviceChange');\n    // send notification only on device change - selection is present\n    if (event.selection) {\n      const notification = SDKToHMS.convertDeviceChangeUpdate(event);\n      this.hmsNotifications.sendDeviceChange(notification);\n    }\n  }\n\n  private async sdkPreviewWithListeners(config: sdkTypes.HMSPreviewConfig) {\n    await this.sdk.preview(config, {\n      onPreview: this.onPreview.bind(this),\n      onError: this.onError.bind(this),\n      onReconnected: this.onReconnected.bind(this),\n      onReconnecting: this.onReconnecting.bind(this),\n      onDeviceChange: this.onDeviceChange.bind(this),\n      onRoomUpdate: this.onRoomUpdate.bind(this),\n      onPeerUpdate: this.onPeerUpdate.bind(this),\n      onNetworkQuality: this.onNetworkQuality.bind(this),\n    });\n    this.sdk.addAudioListener({\n      onAudioLevelUpdate: this.onAudioLevelUpdate.bind(this),\n    });\n  }\n\n  private onNetworkQuality(quality: number) {\n    this.setState(store => {\n      /*\n       * if store does not have peerId yet, fetch from sdk directly.\n       * sdk will have the localpeer already set.\n       */\n      const peerId = store.room.localPeer || this.sdk.getLocalPeer()?.peerId;\n      if (peerId) {\n        store.connectionQualities[peerId] = { peerID: peerId, downlinkQuality: quality };\n      }\n    }, 'ConnectionQuality');\n  }\n\n  private onSessionStoreUpdate(updates: SessionStoreUpdate[]) {\n    this.setSessionStoreValueLocally(updates, 'sessionStoreUpdate');\n  }\n\n  private async startScreenShare(config?: HMSScreenShareConfig) {\n    const isScreenShared = this.store.getState(selectIsLocalScreenShared);\n    if (!isScreenShared) {\n      await this.sdk.startScreenShare(() => this.syncRoomState('screenshareStopped'), config);\n      this.syncRoomState('startScreenShare');\n    } else {\n      this.logPossibleInconsistency(\"start screenshare is called while it's on\");\n    }\n  }\n\n  private async stopScreenShare() {\n    const isScreenShared = this.store.getState(selectIsLocalScreenShared);\n    if (isScreenShared) {\n      await this.sdk.stopScreenShare();\n      this.syncRoomState('stopScreenShare');\n    } else {\n      this.logPossibleInconsistency(\"stop screenshare is called while it's not on\");\n    }\n  }\n\n  private async attachVideoInternal(trackID: string, videoElement: HTMLVideoElement) {\n    const sdkTrack = this.hmsSDKTracks[trackID];\n    if (sdkTrack && sdkTrack.type === 'video') {\n      await this.sdk.attachVideo(sdkTrack as SDKHMSVideoTrack, videoElement);\n    } else {\n      this.logPossibleInconsistency('no video track found to add sink');\n    }\n  }\n\n  /**\n   * This is a very important function as it's responsible for maintaining the source of\n   * truth with maximum efficiency. The efficiency comes from the fact that the only\n   * those portions of the store are updated which have actually changed.\n   * While making a change in this function don't use functions like map, reduce etc.\n   * which return a new copy of the data. Use Object.assign etc. to ensure that if the data\n   * doesn't change reference is also not changed.\n   * The UI and selectors rely on the fact that the store is immutable that is if there is\n   * any change and only if there is a change, they'll get a new copy of the data they're\n   * interested in with a new reference.\n   * @protected\n   */\n  protected syncRoomState(action: string) {\n    action = `${action}_fullSync`;\n    HMSLogger.time(`store-sync-${action}`);\n    const newHmsPeers: Record<HMSPeerID, Partial<HMSPeer>> = {};\n    const newHmsPeerIDs: HMSPeerID[] = []; // to add in room.peers\n    const newHmsTracks: Record<HMSTrackID, Partial<HMSTrack>> = {};\n    const newHmsSDkTracks: Record<HMSTrackID, SDKHMSTrack> = {};\n    const newMediaSettings: Partial<HMSMediaSettings> = {};\n    let newPreview: HMSStore['preview'];\n\n    const sdkPeers: sdkTypes.HMSPeer[] = this.sdk.getPeers();\n\n    // first convert everything in the new format\n    for (const sdkPeer of sdkPeers) {\n      const hmsPeer = SDKToHMS.convertPeer(sdkPeer);\n      newHmsPeers[hmsPeer.id] = hmsPeer;\n      newHmsPeerIDs.push(hmsPeer.id);\n      this.hmsSDKPeers[hmsPeer.id] = sdkPeer;\n\n      const sdkTracks = [sdkPeer.audioTrack, sdkPeer.videoTrack, ...sdkPeer.auxiliaryTracks];\n      for (const sdkTrack of sdkTracks) {\n        if (!sdkTrack) {\n          continue;\n        }\n        const hmsTrack = SDKToHMS.convertTrack(sdkTrack);\n        newHmsTracks[hmsTrack.id] = hmsTrack;\n        newHmsSDkTracks[sdkTrack.trackId] = sdkTrack;\n      }\n\n      if (sdkPeer.isLocal) {\n        const localPeer = sdkPeer as sdkTypes.HMSLocalPeer;\n        newPreview = this.getPreviewFields(localPeer);\n        Object.assign(newMediaSettings, this.getMediaSettings(localPeer));\n      }\n    }\n\n    const recording = this.sdk.getRecordingState();\n    const rtmp = this.sdk.getRTMPState();\n    const hls = this.sdk.getHLSState();\n\n    // then merge them carefully with our store so if something hasn't changed\n    // the reference shouldn't change. Note that the draftStore is an immer draft\n    // object.\n    this.setState(draftStore => {\n      draftStore.room.peers = newHmsPeerIDs;\n      const draftPeers = draftStore.peers;\n      const draftTracks = draftStore.tracks;\n      // the order of below statements are important as merge functions are mutating\n      mergeNewPeersInDraft(draftPeers, newHmsPeers);\n      mergeNewTracksInDraft(draftTracks, newHmsTracks);\n      Object.assign(draftStore.settings, newMediaSettings);\n      this.hmsSDKTracks = newHmsSDkTracks;\n\n      /**\n       * if preview is already present merge,\n       * else set as is(which will create/delete)\n       */\n      if (draftStore.preview?.localPeer && newPreview?.localPeer) {\n        Object.assign(draftStore.preview, newPreview);\n      } else {\n        draftStore.preview = newPreview;\n      }\n      Object.assign(draftStore.roles, SDKToHMS.convertRoles(this.sdk.getRoles()));\n      Object.assign(draftStore.playlist, SDKToHMS.convertPlaylist(this.sdk.getPlaylistManager()));\n      Object.assign(draftStore.room, SDKToHMS.convertRecordingStreamingState(recording, rtmp, hls));\n      Object.assign(draftStore.templateAppData, this.sdk.getTemplateAppData());\n    }, action);\n    HMSLogger.timeEnd(`store-sync-${action}`);\n  }\n\n  protected onPreview(sdkRoom: sdkTypes.HMSRoom) {\n    this.setState(store => {\n      Object.assign(store.room, SDKToHMS.convertRoom(sdkRoom));\n      store.room.roomState = HMSRoomState.Preview;\n    }, 'previewStart');\n    this.syncRoomState('previewSync');\n  }\n\n  protected onJoin(sdkRoom: sdkTypes.HMSRoom) {\n    const playlistManager = this.sdk.getPlaylistManager();\n    this.audioPlaylist = new HMSPlaylist(\n      playlistManager,\n      HMSPlaylistType.audio,\n      this.syncPlaylistState.bind(this),\n      this.store,\n    );\n    this.videoPlaylist = new HMSPlaylist(\n      playlistManager,\n      HMSPlaylistType.video,\n      this.syncRoomState.bind(this),\n      this.store,\n    );\n    this.syncRoomState('joinSync');\n    this.setState(store => {\n      Object.assign(store.room, SDKToHMS.convertRoom(sdkRoom));\n      store.room.isConnected = true;\n      store.room.roomState = HMSRoomState.Connected;\n    }, 'joined');\n    playlistManager.onProgress(this.setProgress);\n    playlistManager.onNewTrackStart((item: sdkTypes.HMSPlaylistItem<any>) => {\n      this.syncPlaylistState(`${item.type}PlaylistUpdate`);\n    });\n    playlistManager.onPlaylistEnded((type: HMSPlaylistType) => {\n      this.syncPlaylistState(`${type}PlaylistEnded`);\n    });\n    playlistManager.onCurrentTrackEnded((item: sdkTypes.HMSPlaylistItem<any>) => {\n      this.hmsNotifications.sendPlaylistTrackEnded(SDKToHMS.convertPlaylistItem(playlistManager, item));\n      this.syncPlaylistState(`${item.type}PlaylistItemEnded`);\n    });\n  }\n\n  protected onRoomUpdate(type: sdkTypes.HMSRoomUpdate, room: sdkTypes.HMSRoom) {\n    this.setState(store => {\n      Object.assign(store.room, SDKToHMS.convertRoom(room));\n    }, type);\n  }\n\n  protected onPeerUpdate(type: sdkTypes.HMSPeerUpdate, sdkPeer: sdkTypes.HMSPeer | sdkTypes.HMSPeer[]) {\n    if (\n      [sdkTypes.HMSPeerUpdate.BECAME_DOMINANT_SPEAKER, sdkTypes.HMSPeerUpdate.RESIGNED_DOMINANT_SPEAKER].includes(type)\n    ) {\n      return; // ignore, high frequency update so no point of syncing peers\n    }\n    if (Array.isArray(sdkPeer)) {\n      const storePeers = this.store.getState(selectPeersMap);\n      const newPeerIds = sdkPeer.filter(peer => !storePeers[peer.peerId]);\n      this.syncRoomState('peersJoined');\n      const connected = this.store.getState(selectIsConnectedToRoom);\n      // This is not send unnecessary notifications while in preview\n      // now room state also call peer list to handle large peers\n      if (connected) {\n        const hmsPeers = [];\n        for (const peer of sdkPeer) {\n          const hmsPeer = this.store.getState(selectPeerByID(peer.peerId));\n          if (hmsPeer) {\n            hmsPeers.push(hmsPeer);\n          }\n        }\n        this.hmsNotifications.sendPeerList(hmsPeers);\n      } else {\n        newPeerIds.forEach(peer => {\n          const hmsPeer = this.store.getState(selectPeerByID(peer.peerId));\n          if (hmsPeer) {\n            this.hmsNotifications.sendPeerUpdate(sdkTypes.HMSPeerUpdate.PEER_JOINED, hmsPeer);\n          }\n        });\n      }\n      return;\n    }\n    this.sendPeerUpdateNotification(type, sdkPeer);\n  }\n\n  protected onTrackUpdate(type: sdkTypes.HMSTrackUpdate, track: SDKHMSTrack, peer: sdkTypes.HMSPeer) {\n    // this check is needed because for track removed case, the notification needs to\n    // be send before the track is removed from store\n    if (type === sdkTypes.HMSTrackUpdate.TRACK_REMOVED) {\n      this.hmsNotifications.sendTrackUpdate(type, track.trackId);\n      this.handleTrackRemove(track, peer);\n    } else {\n      const actionName = TRACK_NOTIFICATION_TYPES[type] || 'trackUpdate';\n      this.syncRoomState(actionName);\n      this.hmsNotifications.sendTrackUpdate(type, track.trackId);\n    }\n  }\n\n  protected onMessageReceived(sdkMessage: sdkTypes.HMSMessage) {\n    const hmsMessage = SDKToHMS.convertMessage(sdkMessage) as HMSMessage;\n    hmsMessage.read = false;\n    hmsMessage.ignored = this.ignoredMessageTypes.includes(hmsMessage.type);\n    this.putMessageInStore(hmsMessage);\n    this.hmsNotifications.sendMessageReceived(hmsMessage);\n  }\n\n  protected putMessageInStore(hmsMessage: HMSMessage) {\n    if (hmsMessage.ignored) {\n      return;\n    }\n    this.setState(store => {\n      hmsMessage.id = String(this.store.getState(selectHMSMessagesCount) + 1);\n      store.messages.byID[hmsMessage.id] = hmsMessage;\n      store.messages.allIDs.push(hmsMessage.id);\n    }, 'newMessage');\n  }\n\n  /*\n   * Note: speakers array contain the value only for peers who have audioLevel != 0\n   */\n  protected onAudioLevelUpdate(sdkSpeakers: sdkTypes.HMSSpeaker[]) {\n    this.setState(store => {\n      const trackIDAudioLevelMap: Record<HMSPeerID, number> = {};\n      sdkSpeakers.forEach(sdkSpeaker => {\n        if (!sdkSpeaker.track || !sdkSpeaker.peer) {\n          return;\n        }\n        const trackID = sdkSpeaker.track.trackId;\n        trackIDAudioLevelMap[trackID] = sdkSpeaker.audioLevel;\n        if (!store.speakers[trackID]) {\n          // Set store instances(peers, tracks) references in speaker, not the new ones received.\n          store.speakers[trackID] = {\n            audioLevel: sdkSpeaker.audioLevel,\n            peerID: sdkSpeaker.peer.peerId,\n            trackID: trackID,\n          };\n        }\n      });\n      const speakerEntries = Object.entries(store.speakers);\n      for (const [trackID, speaker] of speakerEntries) {\n        speaker.audioLevel = trackIDAudioLevelMap[trackID] || 0;\n        if (speaker.audioLevel === 0) {\n          delete store.speakers[trackID];\n        }\n      }\n    }, 'audioLevel');\n  }\n\n  /**\n   * The connection quality update is sent for all peers(one needs to know of) every time.\n   */\n  protected onConnectionQualityUpdate(newQualities: sdkTypes.HMSConnectionQuality[]) {\n    this.setState(store => {\n      const currentPeerIDs = new Set();\n      newQualities.forEach(sdkUpdate => {\n        const peerID = sdkUpdate.peerID;\n        if (!peerID) {\n          return;\n        }\n        currentPeerIDs.add(peerID);\n        if (!store.connectionQualities[peerID]) {\n          store.connectionQualities[peerID] = sdkUpdate;\n        } else {\n          Object.assign(store.connectionQualities[peerID], sdkUpdate);\n        }\n      });\n      const peerIDsStored = Object.keys(store.connectionQualities);\n      for (const storedPeerID of peerIDsStored) {\n        if (!currentPeerIDs.has(storedPeerID)) {\n          // peer is likely no longer there, it wasn't in the update sent by the server\n          delete store.connectionQualities[storedPeerID];\n        }\n      }\n    }, 'connectionQuality');\n  }\n\n  protected onChangeTrackStateRequest(request: SDKHMSChangeTrackStateRequest) {\n    const requestedBy = this.store.getState(selectPeerByID(request.requestedBy?.peerId));\n    const storeTrackID = this.getStoreLocalTrackIDfromSDKTrack(request.track);\n    const track = this.store.getState(selectTrackByID(storeTrackID));\n\n    if (!track) {\n      return this.logPossibleInconsistency(\n        `Not found track for which track state change was requested, ${request.track}`,\n      );\n    }\n\n    if (!request.enabled) {\n      this.syncRoomState('changeTrackStateRequest');\n    }\n\n    this.hmsNotifications.sendChangeTrackStateRequest({\n      requestedBy: requestedBy || undefined,\n      track,\n      enabled: request.enabled,\n    });\n  }\n\n  protected onChangeMultiTrackStateRequest(request: SDKHMSChangeMultiTrackStateRequest) {\n    const requestedBy = this.store.getState(selectPeerByID(request.requestedBy?.peerId));\n\n    if (!request.enabled) {\n      this.syncRoomState('changeMultiTrackStateRequest');\n    }\n\n    const tracks: HMSTrack[] = [];\n    const tracksMap = this.store.getState(selectTracksMap);\n    for (const track of request.tracks) {\n      const storeTrackID = this.getStoreLocalTrackIDfromSDKTrack(track);\n      if (storeTrackID && tracksMap[storeTrackID]) {\n        tracks.push(tracksMap[storeTrackID]);\n      }\n    }\n\n    this.hmsNotifications.sendChangeMultiTrackStateRequest({\n      requestedBy: requestedBy || undefined,\n      tracks,\n      enabled: request.enabled,\n      type: request.type,\n      source: request.source,\n    });\n  }\n\n  protected onReconnected() {\n    this.syncRoomState('reconnectedSync');\n    this.hmsNotifications.sendReconnected();\n    this.setState(store => {\n      store.room.roomState = store.room.isConnected ? HMSRoomState.Connected : HMSRoomState.Preview;\n    }, 'reconnected');\n  }\n\n  protected onReconnecting(sdkError: SDKHMSException) {\n    const error = SDKToHMS.convertException(sdkError);\n    HMSLogger.e('Reconnection: received error from sdk', error);\n    this.hmsNotifications.sendReconnecting(error);\n    this.setState(store => {\n      store.room.roomState = HMSRoomState.Reconnecting;\n      store.errors.push(error);\n    }, 'reconnecting');\n  }\n\n  protected onError(sdkException: SDKHMSException) {\n    const error = SDKToHMS.convertException(sdkException);\n    if (error.isTerminal) {\n      // terminal error leave room as it is not recoverable\n      this.leave().then(() => HMSLogger.e('error from SDK, left room.'));\n      this.setState(store => {\n        store.room.roomState = HMSRoomState.Failed;\n        store.errors.push(error);\n      }, 'errorTerminal');\n    } else {\n      const numExistingErrors = this.store.getState().errors.length;\n      // just in case there is some infinite loop sending errors\n      if (numExistingErrors < 50) {\n        this.setState(store => {\n          store.errors.push(error);\n        }, 'error');\n      }\n    }\n    this.syncRoomState('errorSync'); //TODO: check if need to be done in a different way\n    // send notification\n    this.hmsNotifications.sendError(error);\n    HMSLogger.e('received error from sdk', error instanceof SDKHMSException ? `${error}` : error);\n  }\n\n  private handleTrackRemove(sdkTrack: SDKHMSTrack, sdkPeer: sdkTypes.HMSPeer) {\n    this.setState(draftStore => {\n      const hmsPeer = draftStore.peers[sdkPeer.peerId];\n      const draftTracks = draftStore.tracks;\n      const trackId = sdkTrack.trackId;\n      // find and remove the exact track from hmsPeer\n      if (this.isSameStoreSDKTrack(trackId, hmsPeer?.audioTrack)) {\n        delete hmsPeer?.audioTrack;\n      } else if (this.isSameStoreSDKTrack(trackId, hmsPeer?.videoTrack)) {\n        delete hmsPeer?.videoTrack;\n      } else {\n        const auxiliaryIndex = hmsPeer?.auxiliaryTracks.indexOf(trackId);\n        if (auxiliaryIndex > -1 && this.isSameStoreSDKTrack(trackId, hmsPeer?.auxiliaryTracks[auxiliaryIndex])) {\n          hmsPeer?.auxiliaryTracks.splice(auxiliaryIndex, 1);\n        }\n      }\n      delete draftTracks[trackId];\n      delete this.hmsSDKTracks[trackId];\n    }, 'trackRemoved');\n  }\n\n  private async setEnabledSDKTrack(trackID: string, enabled: boolean) {\n    const track = this.hmsSDKTracks[trackID];\n    if (track) {\n      await track.setEnabled(enabled);\n    } else {\n      this.logPossibleInconsistency(`track ${trackID} not present, unable to enabled/disable`);\n    }\n  }\n\n  private async setSDKLocalVideoTrackSettings(trackID: string, settings: Partial<sdkTypes.HMSVideoTrackSettings>) {\n    const track = this.hmsSDKTracks[trackID] as SDKHMSLocalVideoTrack;\n    if (track) {\n      await track.setSettings(settings);\n    } else {\n      this.logPossibleInconsistency(`local track ${trackID} not present, unable to set settings`);\n    }\n  }\n\n  private async setSDKLocalAudioTrackSettings(trackID: string, settings: Partial<sdkTypes.HMSAudioTrackSettings>) {\n    const track = this.hmsSDKTracks[trackID] as SDKHMSLocalAudioTrack;\n    if (track) {\n      await track.setSettings(settings);\n    } else {\n      this.logPossibleInconsistency(`local track ${trackID} not present, unable to set settings`);\n    }\n  }\n\n  private getMediaSettings(sdkPeer: sdkTypes.HMSPeer): Partial<HMSMediaSettings> {\n    const settings = this.store.getState(selectLocalMediaSettings);\n    const audioTrack = sdkPeer.audioTrack as SDKHMSLocalAudioTrack;\n    const videoTrack = sdkPeer.videoTrack as SDKHMSLocalVideoTrack;\n    return {\n      audioInputDeviceId: audioTrack?.settings.deviceId || settings.audioInputDeviceId,\n      videoInputDeviceId: videoTrack?.settings.deviceId || settings.videoInputDeviceId,\n      audioOutputDeviceId: this.sdk.getAudioOutput().getDevice()?.deviceId,\n    };\n  }\n\n  private getPreviewFields(sdkLocalPeer: sdkTypes.HMSLocalPeer): HMSStore['preview'] {\n    // if room is not in preview, clear preview fields\n    if (!sdkLocalPeer.isInPreview()) {\n      return;\n    }\n\n    const hmsLocalPeer = SDKToHMS.convertPeer(sdkLocalPeer);\n\n    return {\n      localPeer: hmsLocalPeer.id,\n      audioTrack: hmsLocalPeer.audioTrack,\n      videoTrack: hmsLocalPeer.videoTrack,\n      asRole: sdkLocalPeer.asRole?.name || sdkLocalPeer.role?.name,\n    };\n  }\n\n  private async setTrackVolume(value: number, trackId: HMSTrackID) {\n    const track = this.hmsSDKTracks[trackId];\n    if (track) {\n      if (track instanceof SDKHMSAudioTrack) {\n        await track.setVolume(value);\n        this.setState(draftStore => {\n          const track = draftStore.tracks[trackId];\n          if (track && track.type === 'audio') {\n            track.volume = value;\n          }\n        }, 'trackVolume');\n      } else {\n        HMSLogger.w(`track ${trackId} is not an audio track`);\n      }\n    } else {\n      this.logPossibleInconsistency(`track ${trackId} not present, unable to set volume`);\n    }\n  }\n\n  /**\n   * Tells if the trackID is for local peer and video unmute is in process\n   * @private\n   */\n  private localAndVideoUnmuting(trackID: string) {\n    const localPeer = this.store.getState(selectLocalPeer);\n    if (localPeer?.videoTrack !== trackID) {\n      return false;\n    }\n    const displayEnabled = this.store.getState(selectIsLocalVideoDisplayEnabled);\n    const actuallyEnabled = this.store.getState(selectIsLocalVideoEnabled);\n    return displayEnabled && !actuallyEnabled;\n  }\n\n  private logPossibleInconsistency(inconsistency: string) {\n    HMSLogger.w('possible inconsistency detected - ', inconsistency);\n  }\n\n  private async addRemoveVideoPlugin(plugin: HMSVideoPlugin, action: 'add' | 'remove', pluginFrameRate?: number) {\n    if (!plugin) {\n      HMSLogger.w('Invalid plugin received in store');\n      return;\n    }\n    const trackID = this.store.getState(selectLocalVideoTrackID);\n    if (trackID) {\n      const sdkTrack = this.hmsSDKTracks[trackID];\n      if (sdkTrack) {\n        if (action === 'add') {\n          await (sdkTrack as SDKHMSLocalVideoTrack).addPlugin(plugin, pluginFrameRate);\n        } else if (action === 'remove') {\n          await (sdkTrack as SDKHMSLocalVideoTrack).removePlugin(plugin);\n        }\n        this.syncRoomState(`${action}VideoPlugin`);\n      } else {\n        this.logPossibleInconsistency(`track ${trackID} not present, unable to remove plugin`);\n      }\n    }\n  }\n  private async addRemoveAudioPlugin(plugin: HMSAudioPlugin, action: 'add' | 'remove') {\n    if (!plugin) {\n      HMSLogger.w('Invalid plugin received in store');\n      return;\n    }\n    const trackID = this.store.getState(selectLocalAudioTrackID);\n    if (trackID) {\n      const sdkTrack = this.hmsSDKTracks[trackID];\n      if (sdkTrack) {\n        if (action === 'add') {\n          await (sdkTrack as SDKHMSLocalAudioTrack).addPlugin(plugin);\n        } else if (action === 'remove') {\n          await (sdkTrack as SDKHMSLocalAudioTrack).removePlugin(plugin);\n        }\n        this.syncRoomState(`${action}AudioPlugin`);\n      } else {\n        this.logPossibleInconsistency(`track ${trackID} not present, unable to remove plugin`);\n      }\n    }\n  }\n\n  /**\n   * In case of replace track id is changed but not in store. Given the store id, check the real id\n   * sdk is using to refer to the track and match them.\n   */\n  private isSameStoreSDKTrack(sdkTrackID: string, storeTrackID?: string): boolean {\n    if (!storeTrackID) {\n      return false;\n    }\n    return this.hmsSDKTracks[storeTrackID]?.trackId === sdkTrackID;\n  }\n\n  /**\n   * convert new role change requests to store format and save.\n   * keep only one request at a time in store till we figure out how to handle multiple requests at the same time\n   */\n  private onRoleChangeRequest(request: SDKHMSRoleChangeRequest) {\n    this.setState(store => {\n      if (store.roleChangeRequests.length === 0) {\n        store.roleChangeRequests.push(SDKToHMS.convertRoleChangeRequest(request));\n      }\n    }, 'roleChangeRequest');\n  }\n\n  private removeRoleChangeRequest(toRemove: HMSRoleChangeRequest) {\n    this.setState(store => {\n      const index = store.roleChangeRequests.findIndex(req => {\n        return req.token === toRemove.token;\n      });\n      if (index !== -1) {\n        store.roleChangeRequests.splice(index, 1);\n      }\n    }, 'removeRoleChangeRequest');\n  }\n\n  private onRoleUpdate() {\n    this.syncRoomState('roleUpdate');\n  }\n\n  private getStoreLocalTrackIDfromSDKTrack(sdkTrack: SDKHMSLocalTrack) {\n    const trackIDs = this.store.getState(selectLocalTrackIDs);\n    return trackIDs.find(trackID => this.hmsSDKTracks[trackID].trackId === sdkTrack.trackId);\n  }\n\n  private setProgress = ({ type, progress }: sdkTypes.HMSPlaylistProgressEvent) => {\n    this.setState(draftStore => {\n      draftStore.playlist[type].progress = progress;\n      draftStore.playlist[type].currentTime = this.sdk.getPlaylistManager().getCurrentTime(type);\n    }, 'playlistProgress');\n  };\n\n  private syncPlaylistState = (action: string) => {\n    this.setState(draftStore => {\n      Object.assign(draftStore.playlist, SDKToHMS.convertPlaylist(this.sdk.getPlaylistManager()));\n    }, action);\n  };\n\n  private sendPeerUpdateNotification = (type: sdkTypes.HMSPeerUpdate, sdkPeer: sdkTypes.HMSPeer) => {\n    let peer = this.store.getState(selectPeerByID(sdkPeer.peerId));\n    const actionName = PEER_NOTIFICATION_TYPES[type] || 'peerUpdate';\n    this.syncRoomState(actionName);\n    // if peer wasn't available before sync(will happen if event is peer join)\n    if (!peer) {\n      peer = this.store.getState(selectPeerByID(sdkPeer.peerId));\n    }\n    this.hmsNotifications.sendPeerUpdate(type, peer);\n  };\n\n  private setSessionStoreValueLocally(\n    updates: SessionStoreUpdate | SessionStoreUpdate[],\n    actionName = 'setSessionStore',\n  ) {\n    const updatesList: SessionStoreUpdate[] = Array.isArray(updates) ? updates : [updates];\n    this.setState(store => {\n      updatesList.forEach(update => {\n        store.sessionStore[update.key as keyof T['sessionStore']] = update.value;\n      });\n    }, actionName);\n  }\n\n  /**\n   * setState is separate so any future changes to how state change can be done from one place.\n   * @param fn\n   * @param name\n   */\n  private setState: NamedSetState<HMSStore<T>> = (fn, name) => {\n    return this.store.namedSetState(fn, name);\n  };\n}\n", "import { HMSRemoteAudioTrack, HMSRemoteVideoTrack, HMSTrack } from '@100mslive/hms-video';\n\nexport function isRemoteTrack(track: HMSTrack) {\n  return track instanceof HMSRemoteAudioTrack || track instanceof HMSRemoteVideoTrack;\n}\n", "import { HMSLocalTrack as SDKHMSLocalTrack } from '@100mslive/hms-video';\nimport { HMSPeer, HMSPeerID, HMSScreenVideoTrack, HMSTrack, HMSTrackID, HMSVideoTrack } from '../../schema';\nimport { HMSPeerStats, HMSTrackStats } from '../sdkTypes';\n\n/**\n * updates draftPeers with newPeers ensuring minimal reference changes\n * @remarks\n * This is mutable and impure function, it modifies the passed in data to ensure\n * minimal reference changes\n * @param draftPeers the current peers object in store, an immer draft object\n * @param newPeers the latest update which needs to be stored\n * @param newHmsTracks this will be update if required\n * @param newHmsSDkTracks this is future value of local hms tacks map\n */\nexport const mergeNewPeersInDraft = (\n  draftPeers: Record<HMSPeerID, HMSPeer>,\n  newPeers: Record<HMSPeerID, Partial<HMSPeer>>,\n) => {\n  const peerIDs = union(Object.keys(draftPeers), Object.keys(newPeers));\n  for (const peerID of peerIDs) {\n    const oldPeer = draftPeers[peerID];\n    const newPeer = newPeers[peerID];\n    if (isEntityUpdated(oldPeer, newPeer)) {\n      if (areArraysEqual(oldPeer.auxiliaryTracks, newPeer.auxiliaryTracks)) {\n        newPeer.auxiliaryTracks = oldPeer.auxiliaryTracks;\n      }\n      Object.assign(oldPeer, newPeer);\n    } else if (isEntityRemoved(oldPeer, newPeer)) {\n      delete draftPeers[peerID];\n    } else if (isEntityAdded(oldPeer, newPeer)) {\n      draftPeers[peerID] = newPeer as HMSPeer;\n    }\n  }\n};\n\nexport const mergeNewTracksInDraft = (\n  draftTracks: Record<HMSTrackID, HMSTrack>,\n  newTracks: Record<HMSTrackID, Partial<HMSTrack>>,\n) => {\n  const trackIDs = union(Object.keys(draftTracks), Object.keys(newTracks));\n  for (const trackID of trackIDs) {\n    const oldTrack = draftTracks[trackID];\n    const newTrack = newTracks[trackID];\n    if (isEntityUpdated(oldTrack, newTrack)) {\n      mergeTrackArrayFields(oldTrack, newTrack);\n      Object.assign(oldTrack, newTrack);\n    } else if (isEntityRemoved(oldTrack, newTrack)) {\n      delete draftTracks[trackID];\n    } else if (isEntityAdded(oldTrack, newTrack)) {\n      draftTracks[trackID] = newTrack as HMSTrack;\n    }\n  }\n};\n\nexport const mergeNewIndividualStatsInDraft = <TID extends string, T extends HMSPeerStats | HMSTrackStats>(\n  draftStats: Record<TID, T | undefined>,\n  newStats: Record<TID, Partial<T | undefined>>,\n) => {\n  const IDs = union(Object.keys(draftStats), Object.keys(newStats)) as TID[];\n  for (const trackID of IDs) {\n    const oldStat = draftStats[trackID];\n    const newStat = newStats[trackID];\n    if (isEntityUpdated(oldStat, newStat)) {\n      Object.assign(oldStat!, newStat);\n    } else if (isEntityRemoved(oldStat, newStat)) {\n      delete draftStats[trackID];\n    } else if (isEntityAdded(oldStat, newStat)) {\n      draftStats[trackID] = newStat as T;\n    }\n  }\n};\n\nexport const mergeLocalTrackStats = (\n  draftStats: Record<HMSTrackID, HMSTrackStats[] | undefined>,\n  newStats: Record<HMSTrackID, Record<string, HMSTrackStats>>,\n  tracks: SDKHMSLocalTrack[],\n) => {\n  const trackMap: Record<string, HMSTrackStats[]> = tracks.reduce((acc, track) => {\n    // @ts-ignore\n    acc[track.firstTrackId] = Object.values(newStats[track.getTrackIDBeingSent()] || {}).sort((a, b) => {\n      if (!a.rid || !b.rid) {\n        return 0;\n      }\n      return a.rid < b.rid ? -1 : 1;\n    });\n    return acc;\n  }, {});\n  const IDs = union(Object.keys(draftStats), Object.keys(trackMap));\n  for (const trackID of IDs) {\n    if (!trackMap[trackID]) {\n      delete draftStats[trackID];\n      continue;\n    }\n    draftStats[trackID] = trackMap[trackID];\n  }\n};\n\n/**\n * array's are usually created with new reference, avoid that update if both arrays are same\n */\nconst mergeTrackArrayFields = (oldTrack: HMSTrack, newTrack: Partial<HMSTrack>) => {\n  if (oldTrack.plugins && areArraysEqual(oldTrack.plugins, newTrack.plugins)) {\n    newTrack.plugins = oldTrack.plugins;\n  }\n  if (\n    oldTrack.type === 'video' &&\n    oldTrack.layerDefinitions &&\n    areArraysEqual(oldTrack.layerDefinitions, (newTrack as HMSVideoTrack | HMSScreenVideoTrack).layerDefinitions)\n  ) {\n    (newTrack as HMSVideoTrack | HMSScreenVideoTrack).layerDefinitions = oldTrack.layerDefinitions;\n  }\n};\n\nconst isEntityUpdated = <T>(oldItem: T, newItem: T) => oldItem && newItem;\nconst isEntityRemoved = <T>(oldItem: T, newItem: T) => oldItem && !newItem;\nconst isEntityAdded = <T>(oldItem: T, newItem: T) => !oldItem && newItem;\n\n// eslint-disable-next-line complexity\nexport const areArraysEqual = <T>(arr1: T[], arr2?: T[]): boolean => {\n  if (arr1 === arr2 || (arr1.length === 0 && arr2?.length === 0)) {\n    // reference check\n    return true;\n  }\n  if (!arr1 || !arr2 || !(arr1.length === arr2.length)) {\n    return false;\n  }\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst union = <T>(arr1: T[], arr2: T[]): T[] => {\n  const set: Set<T> = new Set();\n  for (const elem of arr1) {\n    set.add(elem);\n  }\n  for (const elem of arr2) {\n    set.add(elem);\n  }\n  return Array.from(set);\n};\n", "import {\n  HMSLocalAudioTrack as SDKHMSLocalAudioTrack,\n  HMSLocalVideoTrack as SDKHMSLocalVideoTrack,\n  HMSRemoteAudioTrack as SDKHMSRemoteAudioTrack,\n  HMSRemoteVideoTrack as SDKHMSRemoteVideoTrack,\n  HMSRoleChangeRequest as SDKHMSRoleChangeRequest,\n  HMSTrack as SDKHMSTrack,\n} from '@100mslive/hms-video';\nimport { areArraysEqual } from './sdkUtils/storeMergeUtils';\nimport * as sdkTypes from './sdkTypes';\nimport {\n  HMSAudioTrack,\n  HMSDeviceChangeEvent,\n  HMSException,\n  HMSMessage,\n  HMSPeer,\n  HMSPeerID,\n  HMSPlaylistItem,\n  HMSPlaylistType,\n  HMSRole,\n  HMSRoleChangeStoreRequest,\n  HMSRoleName,\n  HMSRoom,\n  HMSScreenVideoTrack,\n  HMSTrack,\n  HMSTrackFacingMode,\n  HMSVideoTrack,\n} from '../schema';\n\n/**\n * This file has conversion functions from schema defined in sdk to normalised schema defined in store.\n * A lot of conversions below involve deep clone as once the object goes into store it becomes unmodifiable\n * due to immer, so it can't be mutated later.\n *\n * Objects directly from the SDK are not stored as is and cloned because the SDK might modify it later\n */\n\nexport class SDKToHMS {\n  static convertPeer(sdkPeer: sdkTypes.HMSPeer): Partial<HMSPeer> & Pick<HMSPeer, 'id'> {\n    return {\n      id: sdkPeer.peerId,\n      name: sdkPeer.name,\n      roleName: sdkPeer.role?.name,\n      isLocal: sdkPeer.isLocal,\n      videoTrack: sdkPeer.videoTrack?.trackId,\n      audioTrack: sdkPeer.audioTrack?.trackId,\n      auxiliaryTracks: sdkPeer.auxiliaryTracks.map(track => track.trackId),\n      customerUserId: sdkPeer.customerUserId,\n      metadata: sdkPeer.metadata,\n      joinedAt: sdkPeer.joinedAt,\n    };\n  }\n\n  static convertTrack(sdkTrack: SDKHMSTrack, peerId?: HMSPeerID): HMSTrack {\n    const track: HMSTrack = {\n      id: sdkTrack.trackId,\n      source: sdkTrack.source,\n      type: sdkTrack.type,\n      enabled: sdkTrack.enabled,\n      displayEnabled: sdkTrack.enabled,\n      peerId: sdkTrack.peerId || peerId,\n    } as HMSTrack;\n    this.enrichTrack(track, sdkTrack);\n    return track;\n  }\n\n  static enrichTrack(track: HMSTrack, sdkTrack: SDKHMSTrack) {\n    const mediaSettings = sdkTrack.getMediaTrackSettings();\n\n    if (sdkTrack instanceof SDKHMSRemoteAudioTrack) {\n      (track as HMSAudioTrack).volume = sdkTrack.getVolume() || 0;\n    }\n    SDKToHMS.updateDeviceID(track, sdkTrack);\n    SDKToHMS.enrichLocalTrack(track, sdkTrack);\n    if (track.type === 'video') {\n      if (track.source === 'screen') {\n        // @ts-ignore\n        track.displaySurface = mediaSettings.displaySurface;\n        SDKToHMS.enrichScreenTrack(track as HMSScreenVideoTrack, sdkTrack);\n      } else if (track.source === 'regular') {\n        (track as HMSVideoTrack).facingMode = mediaSettings.facingMode as HMSTrackFacingMode;\n      }\n      track.height = mediaSettings.height;\n      track.width = mediaSettings.width;\n      SDKToHMS.enrichVideoTrack(track as HMSVideoTrack, sdkTrack);\n    }\n    SDKToHMS.enrichPluginsDetails(track, sdkTrack);\n  }\n\n  static enrichLocalTrack(track: HMSTrack, sdkTrack: SDKHMSTrack) {\n    if (sdkTrack instanceof SDKHMSLocalVideoTrack || sdkTrack instanceof SDKHMSLocalAudioTrack) {\n      track.isPublished = sdkTrack.isPublished;\n    }\n  }\n\n  static updateDeviceID(track: HMSTrack, sdkTrack: SDKHMSTrack) {\n    if (sdkTrack instanceof SDKHMSLocalVideoTrack || sdkTrack instanceof SDKHMSLocalAudioTrack) {\n      track.deviceID = sdkTrack.settings.deviceId;\n    } else {\n      track.deviceID = sdkTrack.getMediaTrackSettings()?.deviceId;\n    }\n  }\n\n  static enrichVideoTrack(track: HMSVideoTrack, sdkTrack: SDKHMSTrack) {\n    if (sdkTrack instanceof SDKHMSRemoteVideoTrack) {\n      track.layer = sdkTrack.getLayer();\n      track.preferredLayer = sdkTrack.getPreferredLayer();\n      track.degraded = sdkTrack.degraded;\n    }\n    if (sdkTrack instanceof SDKHMSRemoteVideoTrack || sdkTrack instanceof SDKHMSLocalVideoTrack) {\n      if (!areArraysEqual(sdkTrack.getSimulcastDefinitions(), track.layerDefinitions)) {\n        track.layerDefinitions = sdkTrack.getSimulcastDefinitions();\n      }\n    }\n  }\n\n  static enrichScreenTrack(track: HMSScreenVideoTrack, sdkTrack: SDKHMSTrack) {\n    if (sdkTrack instanceof SDKHMSLocalVideoTrack) {\n      const newCaptureHandle = sdkTrack.getCaptureHandle?.();\n      if (newCaptureHandle?.handle !== track.captureHandle?.handle) {\n        track.captureHandle = newCaptureHandle;\n      }\n      if (sdkTrack.isCurrentTab) {\n        track.displaySurface = 'selfBrowser';\n      }\n    }\n  }\n\n  static enrichPluginsDetails(track: HMSTrack, sdkTrack: SDKHMSTrack) {\n    if (sdkTrack instanceof SDKHMSLocalVideoTrack || sdkTrack instanceof SDKHMSLocalAudioTrack) {\n      if (!areArraysEqual(sdkTrack.getPlugins(), track.plugins)) {\n        track.plugins = sdkTrack.getPlugins();\n      }\n    }\n  }\n\n  static convertRoom(sdkRoom: sdkTypes.HMSRoom): Partial<HMSRoom> {\n    const { recording, rtmp, hls } = SDKToHMS.convertRecordingStreamingState(\n      sdkRoom?.recording,\n      sdkRoom?.rtmp,\n      sdkRoom?.hls,\n    );\n    return {\n      id: sdkRoom.id,\n      name: sdkRoom.name,\n      localPeer: sdkRoom.localPeer?.peerId ?? '',\n      recording,\n      rtmp,\n      hls,\n      sessionId: sdkRoom.sessionId,\n      startedAt: sdkRoom.startedAt,\n      joinedAt: sdkRoom.joinedAt,\n      peerCount: sdkRoom.peerCount,\n    };\n  }\n\n  static convertMessage(sdkMessage: sdkTypes.HMSMessage): Partial<HMSMessage> & Pick<HMSMessage, 'sender'> {\n    return {\n      sender: sdkMessage.sender?.peerId,\n      senderName: sdkMessage.sender?.name,\n      senderRole: sdkMessage.sender?.role?.name,\n      senderUserId: sdkMessage.sender?.customerUserId,\n      recipientPeer: sdkMessage.recipientPeer?.peerId,\n      recipientRoles: sdkMessage.recipientRoles?.map(role => role.name),\n      time: sdkMessage.time,\n      type: sdkMessage.type,\n      message: sdkMessage.message,\n    };\n  }\n\n  static convertRoles(sdkRoles: HMSRole[]): Record<HMSRoleName, HMSRole> {\n    const roles: Record<HMSRoleName, HMSRole> = {};\n    if (sdkRoles) {\n      sdkRoles.forEach(role => {\n        roles[role.name] = role;\n      });\n    }\n    return roles;\n  }\n\n  static convertRoleChangeRequest(req: SDKHMSRoleChangeRequest): HMSRoleChangeStoreRequest {\n    return {\n      requestedBy: req.requestedBy?.peerId,\n      roleName: req.role.name,\n      token: req.token,\n    };\n  }\n\n  static convertException(sdkException: sdkTypes.HMSException): HMSException {\n    return {\n      code: sdkException.code,\n      action: sdkException.action,\n      name: sdkException.name,\n      message: sdkException.message,\n      description: sdkException.description,\n      isTerminal: sdkException.isTerminal,\n      nativeError: sdkException.nativeError,\n      timestamp: new Date(),\n    };\n  }\n\n  static convertDeviceChangeUpdate(sdkDeviceChangeEvent: sdkTypes.HMSDeviceChangeEvent): HMSDeviceChangeEvent {\n    const convertedData: HMSDeviceChangeEvent = {\n      devices: sdkDeviceChangeEvent.devices,\n      selection: sdkDeviceChangeEvent.selection,\n      type: sdkDeviceChangeEvent.type,\n    };\n    if (sdkDeviceChangeEvent.error) {\n      convertedData.error = this.convertException(sdkDeviceChangeEvent.error);\n    }\n    return convertedData;\n  }\n\n  static convertPlaylist(playlistManager: sdkTypes.HMSPlaylistManager) {\n    const audioPlaylist = this.getConvertedPlaylistType(playlistManager, HMSPlaylistType.audio);\n    const videoPlaylist = this.getConvertedPlaylistType(playlistManager, HMSPlaylistType.video);\n    return { audio: audioPlaylist, video: videoPlaylist };\n  }\n\n  static convertPlaylistItem<T>(\n    playlistManager: sdkTypes.HMSPlaylistManager,\n    playlistItem: sdkTypes.HMSPlaylistItem<T>,\n  ): HMSPlaylistItem<T> {\n    const type = playlistItem.type;\n    const currentSelection = playlistManager.getCurrentSelection(type);\n    const isPlaying = playlistManager.isPlaying(type);\n    const isSelected = playlistItem.url === currentSelection?.url;\n\n    return {\n      ...playlistItem,\n      type: playlistItem.type as HMSPlaylistType,\n      selected: isSelected,\n      playing: isSelected && isPlaying,\n    };\n  }\n\n  private static getConvertedPlaylistType(playlistManager: sdkTypes.HMSPlaylistManager, type: HMSPlaylistType) {\n    const convertedPlaylist: Record<string, HMSPlaylistItem<any>> = {};\n    const currentSelection = playlistManager.getCurrentSelection(type);\n    const progress = playlistManager.getCurrentProgress(type);\n    const volume = playlistManager.getVolume(type);\n    const list = playlistManager.getList(type);\n    const currentIndex = playlistManager.getCurrentIndex(type);\n\n    playlistManager.getList(type).forEach(playlistItem => {\n      convertedPlaylist[playlistItem.id] = SDKToHMS.convertPlaylistItem(playlistManager, playlistItem);\n    });\n    return {\n      list: convertedPlaylist,\n      selection: {\n        id: currentSelection?.id,\n        hasPrevious: currentIndex > 0,\n        hasNext: currentIndex < list.length - 1,\n      },\n      progress,\n      volume,\n      currentTime: playlistManager.getCurrentTime(type),\n      playbackRate: playlistManager.getPlaybackRate(type),\n    };\n  }\n\n  static convertRecordingStreamingState(\n    recording?: sdkTypes.HMSRecording,\n    rtmp?: sdkTypes.HMSRTMP,\n    hls?: sdkTypes.HMSHLS,\n  ): { recording: sdkTypes.HMSRecording; rtmp: sdkTypes.HMSRTMP; hls: sdkTypes.HMSHLS } {\n    return {\n      recording: {\n        browser: {\n          running: false,\n          ...recording?.browser,\n        },\n        server: {\n          running: false,\n          ...recording?.server,\n        },\n        hls: { running: false, ...recording?.hls },\n      },\n      rtmp: { running: false, ...rtmp },\n      hls: {\n        variants: hls?.variants?.map(variant => variant) || [],\n        running: !!hls?.running,\n        error: hls?.error,\n      },\n    };\n  }\n}\n", "import { HMSPlaylistManager } from './sdkTypes';\nimport { HMSLogger } from '../../common/ui-logger';\nimport { IHMSStore } from '../IHMSStore';\nimport { HMSGenericTypes, HMSPlaylistItem, HMSPlaylistType, IHMSPlaylistActions } from '../schema';\nimport { selectAudioPlaylist, selectVideoPlaylist } from '../selectors';\n\nexport class HMSPlaylist<T extends HMSGenericTypes> implements IHMSPlaylistActions {\n  private type: HMSPlaylistType;\n  constructor(\n    private playlistManager: HMSPlaylistManager,\n    type: HMSPlaylistType,\n    private syncPlaylistState: (action: string) => void,\n    private store: IHMSStore<T>,\n  ) {\n    this.type = type;\n  }\n\n  async play(id: string): Promise<void> {\n    if (!id) {\n      HMSLogger.w('Please pass id to play');\n      return;\n    }\n    await this.playlistManager.setEnabled(true, { id, type: this.type });\n  }\n\n  async pause(): Promise<void> {\n    const selector = this.type === HMSPlaylistType.audio ? selectAudioPlaylist : selectVideoPlaylist;\n    const selection = this.store.getState(selector.selection);\n    if (!selection.id) {\n      HMSLogger.w('No item is currently playing to pause');\n      return;\n    }\n    await this.playlistManager.setEnabled(false, { id: selection.id, type: this.type });\n  }\n\n  async playNext(): Promise<void> {\n    await this.playlistManager.playNext(this.type);\n  }\n\n  async playPrevious(): Promise<void> {\n    await this.playlistManager.playPrevious(this.type);\n  }\n\n  seek(seekValue: number): void {\n    this.playlistManager.seek(seekValue, this.type);\n    this.syncPlaylistState(`seekOn${this.type}Playlist`);\n  }\n\n  seekTo(seekValue: number): void {\n    this.playlistManager.seekTo(seekValue, this.type);\n    this.syncPlaylistState(`seekToOn${this.type}Playlist`);\n  }\n\n  setVolume(volume: number): void {\n    this.playlistManager.setVolume(volume, this.type);\n    this.syncPlaylistState(`setVolumeOn${this.type}Playlist`);\n  }\n\n  setList<T>(list: HMSPlaylistItem<T>[]): void {\n    this.playlistManager.setList(list);\n    this.syncPlaylistState(`setListOn${this.type}Playlist`);\n  }\n\n  async stop(): Promise<void> {\n    await this.playlistManager.stop(this.type);\n    this.syncPlaylistState(`stop${this.type}Playlist`);\n  }\n\n  setIsAutoplayOn(autoplay: boolean) {\n    this.playlistManager.setIsAutoplayOn(this.type, autoplay);\n  }\n\n  setPlaybackRate(playbackRate: number) {\n    this.playlistManager.setPlaybackRate(this.type, playbackRate);\n    this.syncPlaylistState(`set${this.type}PlaybackRate`);\n  }\n\n  async removeItem(id: string) {\n    const removed = await this.playlistManager.removeItem(id, this.type);\n    if (removed) {\n      this.syncPlaylistState(`remove${this.type}PlaylistItem`);\n    }\n    return removed;\n  }\n\n  async clearList() {\n    await this.playlistManager.clearList(this.type);\n    this.syncPlaylistState(`clear${this.type}Playlist`);\n  }\n}\n", "import { HMSSdk, SessionStoreUpdate } from '@100mslive/hms-video';\nimport { IHMSSessionStoreActions } from '../schema';\n\nexport class HMSSessionStore<T extends Record<string, any>> implements IHMSSessionStoreActions<T> {\n  constructor(\n    private sdk: HMSSdk,\n    private setLocally: (updates: SessionStoreUpdate | SessionStoreUpdate[], actionName?: string) => void,\n  ) {}\n\n  private get sdkSessionStore() {\n    return this.sdk.getSessionStore();\n  }\n\n  async set<K extends keyof T>(key: K, value?: T[K]) {\n    const { value: latestValue } = await this.sdkSessionStore.set(String(key), value);\n    this.setLocally({ key: key as string, value: latestValue });\n  }\n\n  async observe(keys: keyof T | Array<keyof T>) {\n    const stringifiedKeys: string[] = Array.isArray(keys) ? keys.map(key => String(key)) : [String(keys)];\n    await this.sdkSessionStore.observe(stringifiedKeys);\n  }\n\n  async unobserve(keys: keyof T | Array<keyof T>) {\n    const stringifiedKeys: string[] = Array.isArray(keys) ? keys.map(key => String(key)) : [String(keys)];\n    await this.sdkSessionStore.unobserve(stringifiedKeys);\n  }\n}\n", "import { HMSLogger } from '../../common/ui-logger';\nimport { HMSGenericTypes, HMSPeer, IHMSStore, selectIsConnectedToRoom, selectPeers } from '../../core';\nimport { IHMSActions } from '../../core/IHMSActions';\n\n/**\n * Log data of audio level and speaker speaking periodically to beam for transcript\n * diarization.\n */\nexport class BeamSpeakerLabelsLogger<T extends HMSGenericTypes> {\n  private audioContext?: AudioContext;\n  private readonly intervalMs: number;\n  private shouldMonitor: boolean;\n  private hasStarted: boolean;\n  private unsubs: any[];\n  private readonly analysers: Record<string, AnalyserNode>;\n  private readonly store: IHMSStore<T>;\n  private actions: IHMSActions<T>;\n  constructor(store: IHMSStore<T>, actions: IHMSActions<T>) {\n    this.intervalMs = 100;\n    this.shouldMonitor = false;\n    this.hasStarted = false;\n    this.unsubs = [];\n    this.analysers = {};\n    this.store = store;\n    this.actions = actions;\n  }\n\n  async start() {\n    if (this.hasStarted) {\n      return;\n    }\n    this.hasStarted = true;\n    HMSLogger.d('starting audio level monitor for remote peers', this.store);\n    const isConnected = this.store.getState(selectIsConnectedToRoom);\n    HMSLogger.d('starting audio levels is connected to room', isConnected);\n    if (isConnected) {\n      await this.monitorAudioLevels();\n    }\n    const unsub = this.store.subscribe(this.monitorAudioLevels.bind(this), selectIsConnectedToRoom);\n    this.unsubs.push(unsub);\n  }\n\n  async stop() {\n    if (!this.hasStarted) {\n      return;\n    }\n    this.hasStarted = false;\n    this.shouldMonitor = false;\n    this.unsubs.forEach(unsub => unsub());\n    HMSLogger.d('stopped audio level monitor for remote peers');\n  }\n\n  async monitorAudioLevels() {\n    const isConnected = this.store.getState(selectIsConnectedToRoom);\n    if (!isConnected) {\n      if (this.shouldMonitor) {\n        HMSLogger.i('room no longer connected, stopping audio level monitoring for remote');\n        this.shouldMonitor = false;\n      }\n      return;\n    }\n    if (this.shouldMonitor) {\n      return;\n    }\n    HMSLogger.i('monitoring audio levels');\n    this.shouldMonitor = true;\n    const loop = () => {\n      if (this.shouldMonitor) {\n        this.logAllPeersAudioLevels();\n        setTimeout(loop, this.intervalMs);\n      } else {\n        HMSLogger.i('stopped monitoring audio levels');\n      }\n    };\n    setTimeout(loop, 1000);\n  }\n\n  // eslint-disable-next-line complexity\n  async logAllPeersAudioLevels() {\n    if (!window.__triggerBeamEvent__) {\n      return;\n    }\n    // optimise this to selectTracks instead of selecting peers\n    const allPeers = this.store.getState(selectPeers);\n    const peers = allPeers.filter(peer => !!peer.audioTrack);\n    const peerAudioLevels = [];\n    for (const peer of peers) {\n      // @ts-ignore\n      const sdkTrack = this.actions.hmsSDKTracks[peer.audioTrack];\n      const nativeStream: MediaStream = sdkTrack?.stream?.nativeStream;\n      if (!peer.joinedAt) {\n        continue;\n      }\n      if (nativeStream) {\n        const peerLevel = await this.getAudioLevel(peer, nativeStream);\n        if (peerLevel.level > 0) {\n          peerAudioLevels.push(peerLevel);\n        }\n      }\n    }\n    if (peerAudioLevels.length > 0) {\n      const payload = {\n        event: 'app-audio-level',\n        data: peerAudioLevels,\n      };\n      // HMSLogger.d('logging audio levels', peerAudioLevels);\n      window.__triggerBeamEvent__(JSON.stringify(payload));\n    }\n  }\n\n  async getAudioLevel(peer: HMSPeer, stream: MediaStream) {\n    if (!this.analysers[stream.id]) {\n      this.analysers[stream.id] = this.createAnalyserNode(stream);\n    }\n    const analyserNode = this.analysers[stream.id];\n    const level = this.calculateAudioLevel(analyserNode);\n    return {\n      peerId: peer.id,\n      peerName: peer.name,\n      level,\n    };\n  }\n\n  createAnalyserNode(stream: MediaStream) {\n    if (!this.audioContext) {\n      this.audioContext = new AudioContext();\n    }\n    const analyser = this.audioContext.createAnalyser();\n    const source = this.audioContext.createMediaStreamSource(stream);\n    source.connect(analyser);\n    return analyser;\n  }\n\n  calculateAudioLevel(analyserNode: AnalyserNode) {\n    const data = new Uint8Array(analyserNode.fftSize);\n    analyserNode.getByteTimeDomainData(data);\n    const lowest = 0.009;\n    let max = lowest;\n    for (const frequency of data) {\n      max = Math.max(max, (frequency - 128) / 128);\n    }\n    const normalized = (Math.log(lowest) - Math.log(max)) / Math.log(lowest);\n    const percent = Math.ceil(Math.min(Math.max(normalized * 100, 0), 100));\n    return percent;\n  }\n}\n", "import { isBrowser } from '@100mslive/hms-video';\n\nexport const storeNameWithTabTitle = (storeName: string) => {\n  return isBrowser ? `${storeName} ${document.title}` : storeName;\n};\n", "import { HMSGenericTypes, HMSNotifications, IHMSNotifications, IHMSStore } from '../../core';\nimport { IHMSActions } from '../../core/IHMSActions';\nimport { IHMSStoreReadOnly } from '../../core/IHMSStore';\n\n/**\n * @internal\n */\nexport class BeamControllerStore<T extends HMSGenericTypes = { sessionStore: Record<string, any> }> {\n  // perform action to add, remove beam\n  private readonly actions: IHMSActions<T>;\n  // get all details from store about room, peers, tracks.\n  private readonly store: IHMSStore<T>;\n  // all details from the notification\n  private readonly notifications: HMSNotifications;\n\n  constructor(hmsStore: IHMSStore<T>, hmsActions: IHMSActions<T>, hmsNotifications: HMSNotifications) {\n    this.store = hmsStore;\n    this.actions = hmsActions;\n    this.notifications = hmsNotifications;\n  }\n\n  /**\n   * A reactive store which has a subscribe method you can use in combination with selectors\n   * to subscribe to a subset of the store. The store serves as a single source of truth for\n   * all data related to the corresponding HMS Room.\n   */\n  getStore(): IHMSStoreReadOnly {\n    return this.store;\n  }\n\n  /**\n   * Any action which may modify the store or may need to talk to the SDK will happen\n   * through the IHMSActions instance returned by this\n   */\n  getActions(): IHMSActions {\n    return this.actions;\n  }\n\n  /**\n   * This return notification handler function to which you can pass your callback to\n   * receive notifications like peer joined, peer left, etc. to show in your UI or use\n   * for analytics\n   */\n  getNotifications(): IHMSNotifications {\n    return { onNotification: this.notifications.onNotification };\n  }\n}\n", "import { HMSPeerStats, HMSSdk, HMSTrackStats, HMSWebrtcStats } from '@100mslive/hms-video';\nimport { mergeLocalTrackStats, mergeNewIndividualStatsInDraft } from '../hmsSDKStore/sdkUtils/storeMergeUtils';\nimport { IHMSStatsStore, IHMSStore } from '../IHMSStore';\nimport { createDefaultStatsStore, HMSPeerID, HMSRoomState, HMSTrack, HMSTrackID } from '../schema';\nimport {\n  selectLocalAudioTrackID,\n  selectLocalPeerID,\n  selectLocalVideoTrackID,\n  selectRoomState,\n  selectTracksMap,\n} from '../selectors';\n\ntype Unsubscribe = (() => void) | undefined;\nexport const subscribeToSdkWebrtcStats = (sdk: HMSSdk, webrtcStore: IHMSStatsStore, store: IHMSStore) => {\n  // also used as flag to check if webrtc internals has been initialised\n  let unsubscribe: Unsubscribe;\n  /**\n   * Connected to room, webrtc internals can be initialized\n   */\n  if (store.getState(selectRoomState) === HMSRoomState.Connected) {\n    unsubscribe = initAndSubscribeWebrtcStore(sdk, webrtcStore, store);\n  }\n\n  /**\n   * Subscribe to room state for 2 purposes:\n   * - unsubscribe on leave\n   * - if internals is called before join is completed, init internals when roomState changes to connected\n   */\n  store.subscribe(roomState => {\n    if ([HMSRoomState.Connected, HMSRoomState.Reconnecting].includes(roomState)) {\n      if (!unsubscribe) {\n        unsubscribe = initAndSubscribeWebrtcStore(sdk, webrtcStore, store);\n      }\n      // room state can go to disconnecting and back to connected if leave fails, we don't want to resubscribe in that case\n    } else if ([HMSRoomState.Disconnected, HMSRoomState.Failed].includes(roomState)) {\n      if (unsubscribe) {\n        resetHMSStatsStore(webrtcStore, roomState);\n        unsubscribe();\n        // set flag to defined after unsubscribing to enable subscribing again\n        unsubscribe = undefined;\n      }\n    }\n  }, selectRoomState);\n};\n\nconst initAndSubscribeWebrtcStore = (sdk: HMSSdk, webrtcStore: IHMSStatsStore, store: IHMSStore) => {\n  const unsubLocalPeer = updateLocalPeerInWebrtcStore(store, webrtcStore);\n\n  sdk.getWebrtcInternals()?.start();\n  const unsubSdkStats = sdk\n    .getWebrtcInternals()\n    ?.onStatsChange(stats => updateWebrtcStoreStats(webrtcStore, stats, store, sdk));\n\n  return () => {\n    unsubLocalPeer();\n    unsubSdkStats && unsubSdkStats();\n  };\n};\n\nconst updateLocalPeerInWebrtcStore = (store: IHMSStore, webrtcStore: IHMSStatsStore) => {\n  let unsubID: Unsubscribe, unsubVideoTrackID: Unsubscribe, unsubAudioTrackID: Unsubscribe;\n  if (store.getState(selectLocalPeerID)) {\n    webrtcStore.namedSetState(draft => {\n      draft.localPeer.id = store.getState(selectLocalPeerID);\n    }, 'localpeer-id');\n  } else {\n    unsubID = store.subscribe(localPeerID => {\n      localPeerID &&\n        webrtcStore.namedSetState(draft => {\n          draft.localPeer.id = localPeerID;\n        }, 'localpeer-id');\n    }, selectLocalPeerID);\n  }\n\n  if (store.getState(selectLocalVideoTrackID)) {\n    webrtcStore.namedSetState(draft => {\n      draft.localPeer.videoTrack = store.getState(selectLocalVideoTrackID);\n    }, 'localpeer-videotrack-id');\n  } else {\n    unsubVideoTrackID = store.subscribe(videoTrackID => {\n      videoTrackID &&\n        webrtcStore.namedSetState(draft => {\n          draft.localPeer.videoTrack = videoTrackID;\n        }, 'localpeer-videotrack-id');\n    }, selectLocalVideoTrackID);\n  }\n\n  if (store.getState(selectLocalAudioTrackID)) {\n    webrtcStore.namedSetState(draft => {\n      draft.localPeer.audioTrack = store.getState(selectLocalAudioTrackID);\n    }, 'localpeer-audiotrack-id');\n  } else {\n    unsubAudioTrackID = store.subscribe(audioTrackID => {\n      audioTrackID &&\n        webrtcStore.namedSetState(draft => {\n          draft.localPeer.audioTrack = audioTrackID;\n        }, 'localpeer-audiotrack-id');\n    }, selectLocalAudioTrackID);\n  }\n\n  return () => {\n    unsubID?.();\n    unsubVideoTrackID?.();\n    unsubAudioTrackID?.();\n  };\n};\n\nconst updateWebrtcStoreStats = (\n  webrtcStore: IHMSStatsStore,\n  stats: HMSWebrtcStats,\n  hmsStore: IHMSStore,\n  sdk: HMSSdk,\n) => {\n  const tracks: Record<HMSTrackID, HMSTrack> = hmsStore.getState(selectTracksMap);\n  webrtcStore.namedSetState(store => {\n    const localPeerID = hmsStore.getState(selectLocalPeerID);\n    const newTrackStats: Record<HMSTrackID, HMSTrackStats> = {};\n    const trackIDs = Object.keys(tracks).filter(trackID => tracks[trackID].peerId !== localPeerID);\n\n    for (const trackID of trackIDs) {\n      const sdkTrackStats = stats.getRemoteTrackStats(trackID);\n      if (sdkTrackStats) {\n        newTrackStats[trackID] = sdkTrackStats;\n      }\n    }\n\n    mergeNewIndividualStatsInDraft<HMSTrackID, HMSTrackStats>(store.remoteTrackStats, newTrackStats);\n\n    // @TODO: Include all peer stats, own ticket, transmit local peer stats to other peer's using biz\n    const newPeerStats = { [localPeerID]: stats.getLocalPeerStats() };\n    mergeNewIndividualStatsInDraft<HMSPeerID, HMSPeerStats>(store.peerStats, newPeerStats);\n    // @ts-ignore\n    mergeLocalTrackStats(store.localTrackStats, stats.getLocalTrackStats(), sdk.store.getLocalPeerTracks());\n  }, 'webrtc-stats');\n};\n\nconst resetHMSStatsStore = (store: IHMSStatsStore, reason = 'resetState') => {\n  store.namedSetState(draft => {\n    Object.assign(draft, createDefaultStatsStore());\n  }, reason);\n};\n", "import { Subscribe } from 'zustand/vanilla';\nimport { HMSSdk } from '@100mslive/hms-video';\nimport { subscribeToSdkWebrtcStats } from './webrtc-stats-store';\nimport { storeNameWithTabTitle } from '../../common/storeName';\nimport { GetState, IHMSStatsStore, IHMSStatsStoreReadOnly, IHMSStore } from '../IHMSStore';\nimport { createDefaultStatsStore, HMSReactiveStore, HMSStatsStore, selectRoomState } from '..';\n\n/**\n * @internal\n */\nexport class HMSStats implements IHMSStatsStoreReadOnly {\n  readonly getState: GetState<HMSStatsStore>;\n  readonly subscribe: Subscribe<HMSStatsStore>;\n  readonly getPublishPeerConnection: () => Promise<RTCPeerConnection | undefined>;\n  readonly getSubscribePeerConnection: () => Promise<RTCPeerConnection | undefined>;\n  private readonly store: IHMSStatsStore;\n\n  constructor(private hmsStore: IHMSStore, private sdk?: HMSSdk) {\n    this.store = HMSReactiveStore.createNewHMSStore<HMSStatsStore>(\n      storeNameWithTabTitle('HMSStatsStore'),\n      createDefaultStatsStore,\n    );\n\n    this.getState = this.store.getState;\n    this.subscribe = this.store.subscribe;\n\n    this.getPublishPeerConnection = () =>\n      new Promise<RTCPeerConnection | undefined>(resolve => {\n        if (this.hmsStore.getState(selectRoomState) === 'Connected') {\n          resolve(this.sdk?.getWebrtcInternals()?.getPublishPeerConnection());\n        } else {\n          this.hmsStore.subscribe(roomState => {\n            if (roomState === 'Connected') {\n              resolve(this.sdk?.getWebrtcInternals()?.getPublishPeerConnection());\n            }\n          }, selectRoomState);\n        }\n      });\n\n    this.getSubscribePeerConnection = () =>\n      new Promise<RTCPeerConnection | undefined>(resolve => {\n        if (this.hmsStore.getState(selectRoomState) === 'Connected') {\n          resolve(this.sdk?.getWebrtcInternals()?.getSubscribePeerConnection());\n        } else {\n          this.hmsStore.subscribe(roomState => {\n            if (roomState === 'Connected') {\n              resolve(this.sdk?.getWebrtcInternals()?.getSubscribePeerConnection());\n            }\n          }, selectRoomState);\n        }\n      });\n\n    if (!this.sdk) {\n      return;\n    }\n\n    subscribeToSdkWebrtcStats(this.sdk, this.store, this.hmsStore);\n  }\n}\n", "import { createSelector } from 'reselect';\nimport { HMSPreferredSimulcastLayer, RID, simulcastMapping } from '../hmsSDKStore/sdkTypes';\nimport { HMSPeerID, HMSStatsStore, HMSTrackID } from '../schema';\nimport { byIDCurry } from '../selectors/common';\n\nconst selectLocalPeerID = (store: HMSStatsStore) => store.localPeer.id;\nconst selectLocalAudioTrackID = (store: HMSStatsStore) => store.localPeer.audioTrack;\nconst selectLocalVideoTrackID = (store: HMSStatsStore) => store.localPeer.videoTrack;\nconst selectPeerID = (_store: HMSStatsStore, peerID: HMSPeerID | undefined) => peerID;\nconst selectTrackID = (_store: HMSStatsStore, trackID: HMSTrackID | undefined) => trackID;\nconst selectRemoteTrackStatsMap = (store: HMSStatsStore) => store.remoteTrackStats;\nconst selectPeerStatsMap = (store: HMSStatsStore) => store.peerStats;\nconst selectLocalTrackStatsMap = (store: HMSStatsStore) => store.localTrackStats;\n\n/**\n * Local peer stats selectors\n */\nconst localPeerStats = createSelector(\n  [selectPeerStatsMap, selectLocalPeerID],\n  (storePeerStats, localPeerID) => storePeerStats[localPeerID],\n);\n\n/**\n *  The total number of packets lost during the call\n */\nconst packetsLost = createSelector(localPeerStats, localPeerStats => localPeerStats?.subscribe?.packetsLost);\n\nconst jitter = createSelector(localPeerStats, localPeerStats => localPeerStats?.subscribe?.jitter);\n\n/**\n * The bitrate at which all the local tracks are being published at\n */\nconst publishBitrate = createSelector(localPeerStats, localPeerStats => localPeerStats?.publish?.bitrate);\n\n/**\n * The bitrate at which all the remote tracks are being received at\n */\nconst subscribeBitrate = createSelector(localPeerStats, localPeerStats => localPeerStats?.subscribe?.bitrate);\n\n/**\n * The total bitrate available for publishing\n */\nconst availablePublishBitrate = createSelector(\n  localPeerStats,\n  localPeerStats => localPeerStats?.publish?.availableOutgoingBitrate,\n);\n\n/**\n * The total bitrate available for subscribing to remote peers\n */\nconst availableSubscribeBitrate = createSelector(\n  localPeerStats,\n  localPeerStats => localPeerStats?.subscribe?.availableIncomingBitrate,\n);\n\n/**\n * The total bytes sent by the local peer\n */\nconst totalBytesSent = createSelector(localPeerStats, localPeerStats => localPeerStats?.publish?.bytesSent);\n\n/**\n * The total bytes received by the local peer\n */\nconst totalBytesReceived = createSelector(localPeerStats, localPeerStats => localPeerStats?.subscribe?.bytesReceived);\n\n/**\n * By ID Selectors\n * To be used for remote tracks\n */\n\nconst selectPeerStatsByIDBare = createSelector([selectPeerStatsMap, selectPeerID], (storePeerStats, peerID) =>\n  peerID ? storePeerStats[peerID] : undefined,\n);\n\nconst selectTrackStatsByIDBare = createSelector(\n  [selectRemoteTrackStatsMap, selectTrackID],\n  (storeTrackStats, trackID) => (trackID ? storeTrackStats[trackID] : undefined),\n);\n\nconst selectLocalTrackStatsByIDBare = createSelector(\n  [selectLocalTrackStatsMap, selectTrackID],\n  (storeLocalTrackStats, trackID) => (trackID ? storeLocalTrackStats[trackID] : undefined),\n);\n\n/**\n * Stats(bitrate, bytes sent/received, etc...) for a single peer given the peer ID\n */\nconst peerStatsByID = byIDCurry(selectPeerStatsByIDBare);\n\n/**\n * Stats(bitrate, bytes sent/received, framerate, FPS, etc...) for a remote track\n */\nconst trackStatsByID = byIDCurry(selectTrackStatsByIDBare);\n\n/**\n * Local track stats selectors\n */\n\nconst localAudioTrackStats = createSelector(\n  [selectLocalTrackStatsMap, selectLocalAudioTrackID],\n  (trackStats, trackID) => (trackID ? trackStats[trackID]?.[0] : undefined),\n);\n\nconst localAudioTrackStatsByID = byIDCurry(\n  createSelector(selectLocalTrackStatsByIDBare, trackStats => trackStats?.[0]),\n);\n\nconst localVideoTrackStats = createSelector(\n  [selectLocalTrackStatsMap, selectLocalVideoTrackID],\n  (trackStats, trackID) => (trackID ? trackStats[trackID]?.[0] : undefined),\n);\n\nconst localVideoTrackStatsByID = byIDCurry(createSelector(selectLocalTrackStatsByIDBare, trackStats => trackStats));\n\nconst localVideoTrackStatsByLayer = (layer?: HMSPreferredSimulcastLayer) =>\n  byIDCurry(\n    createSelector(selectLocalTrackStatsByIDBare, stats => {\n      const rid = (Object.keys(simulcastMapping) as RID[]).find(key => simulcastMapping[key] === layer);\n      return layer ? stats?.find(stat => stat.rid === rid) || stats?.[0] : stats?.[0];\n    }),\n  );\n\nexport const selectHMSStats = {\n  localPeerStats,\n  packetsLost,\n  jitter,\n  publishBitrate,\n  subscribeBitrate,\n  availablePublishBitrate,\n  availableSubscribeBitrate,\n  totalBytesSent,\n  totalBytesReceived,\n  peerStatsByID,\n  trackStatsByID,\n  localAudioTrackStatsByID,\n  localVideoTrackStatsByID,\n  localVideoTrackStatsByLayer,\n  localAudioTrackStats,\n  localVideoTrackStats,\n};\n"],
  "mappings": "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",
  "names": []
}
